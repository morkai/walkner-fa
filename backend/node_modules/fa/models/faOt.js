// Part of <https://miracle.systems/p/walkner-fa> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const deepEqual = require('deep-equal');
const {transliterate} = require('transliteration');
const lastModifiedPaths = require('h5-mongoose/plugins/lastModifiedPaths');
const userInfoSchema = require('user/models/userInfoSchema');
const arrayToObject = require('util/arrayToObject');
const collectUsers = require('./collectUsers');

exports.name = 'FaOt';

exports.setUp = (app, mongoose) =>
{
  const STAGE_PROPS = {
    protocol: [
      'stage',
      'protocolDate',
      'inventoryNo',
      'serialNo',
      'assetName',
      'lineSymbol',
      'zplx',
      'owner',
      'committee',
      'supplier',
      'protocolFile',
      'photoFile',
      'attachmentFile'
    ],
    authorize: [
      'stage',
      'attachmentFile'
    ],
    document: [
      'stage',
      'documentNo',
      'documentDate',
      'assetName',
      'inventoryNo',
      'serialNo',
      'lineSymbol',
      'zplx',
      'supplier',
      'owner',
      'value',
      'costCenter',
      'vendorNo',
      'vendorName',
      'checklistFile',
      'certificateFile',
      'outlayFile',
      'nameplateFile',
      'photoFile',
      'attachmentFile'
    ],
    verify: [
      'stage',
      'assetName',
      'zplx',
      'assetClass',
      'inventoryNo',
      'serialNo',
      'fiscalValue',
      'deprecationRate',
      'economicPeriod',
      'fiscalPeriod',
      'tplNotes',
      'attachmentFile'
    ],
    accept: [
      'stage',
      'attachmentFile'
    ],
    record: [
      'stage',
      'sapNo',
      'accountingNo',
      'attachmentFile'
    ],
    finished: [
      'protocolDate',
      'documentDate',
      'inventoryNo',
      'serialNo',
      'lineSymbol',
      'assetName',
      'zplx',
      'owner',
      'committee',
      'supplier',
      'value',
      'fiscalValue',
      'costCenter',
      'assetClass',
      'vendorNo',
      'vendorName',
      'deprecationRate',
      'economicPeriod',
      'fiscalPeriod',
      'sapNo',
      'accountingNo',
      'odwNo',
      'tplNotes',
      'protocolFile',
      'checklistFile',
      'outlayFile',
      'certificateFile',
      'nameplateFile',
      'photoFile',
      'attachmentFile'
    ],
    cancelled: [
      'stage'
    ]
  };
  const STAGES = Object.keys(STAGE_PROPS);

  const attachmentSchema = new mongoose.Schema({
    hash: String,
    type: String,
    size: Number,
    name: String
  }, {
    _id: false
  });

  const zplxSchema = new mongoose.Schema({
    code: {
      type: String,
      match: /^[0-9]{8}$/,
      minlength: 8,
      maxlength: 8
    },
    value: {
      type: Number,
      min: 0
    },
    auc: {
      type: String,
      default: ''
    }
  }, {
    _id: false
  });

  const changeSchema = new mongoose.Schema({
    date: {
      type: Date,
      required: true
    },
    user: userInfoSchema,
    data: {},
    comment: {
      type: String,
      trim: true,
      default: ''
    }
  }, {
    _id: false,
    minimize: false
  });

  const schema = new mongoose.Schema({
    createdAt: {
      type: Date,
      required: true
    },
    createdBy: {
      type: userInfoSchema,
      required: true
    },
    updatedAt: {
      type: Date,
      default: null
    },
    updatedBy: {
      type: userInfoSchema,
      default: null
    },
    stage: {
      type: String,
      required: true,
      enum: STAGES
    },
    stageChangedAt: arrayToObject(STAGES, Date),
    stageChangedBy: arrayToObject(STAGES, userInfoSchema),
    protocolNeeded: {
      type: Boolean,
      required: true
    },
    commissioningType: {
      type: String,
      required: true,
      enum: [null, 'new-asset', 'inc-asset']
    },
    usageDestination: {
      type: String,
      required: true,
      enum: ['factory', 'external-supplier']
    },
    protocolNo: {
      type: String,
      default: ''
    },
    protocolNoInc: {
      type: Number,
      default: 0
    },
    documentNo: {
      type: String,
      default: ''
    },
    documentNoInc: {
      type: Number,
      default: 0
    },
    date: Date,
    protocolDate: {
      type: Date,
      default: null
    },
    documentDate: {
      type: Date,
      default: null
    },
    inventoryNo: {
      type: String,
      trim: true,
      default: ''
    },
    serialNo: {
      type: String,
      trim: true,
      default: ''
    },
    assetName: {
      type: String,
      trim: true,
      default: ''
    },
    assetNameSearch: String,
    lineSymbol: {
      type: String,
      trim: true,
      default: ''
    },
    zplx: [zplxSchema],
    owner: {
      type: userInfoSchema,
      default: null
    },
    committee: [userInfoSchema],
    supplier: {
      type: String,
      trim: true,
      default: ''
    },
    supplierSearch: String,
    value: {
      type: Number,
      min: 0,
      default: 0
    },
    fiscalValue: {
      type: Number,
      min: 0,
      default: 0
    },
    assetClass: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'FaAssetClass',
      default: null
    },
    costCenter: {
      type: String,
      ref: 'FaCostCenter',
      default: null
    },
    vendorNo: {
      type: String,
      trim: true,
      default: ''
    },
    vendorName: {
      type: String,
      trim: true,
      default: ''
    },
    vendorNameSearch: String,
    deprecationRate: {
      type: Number,
      min: 0,
      max: 100,
      default: 0
    },
    economicPeriod: {
      type: Number,
      min: 0,
      max: 1200,
      default: 0
    },
    fiscalPeriod: {
      type: Number,
      min: 0,
      max: 1200,
      default: 0
    },
    sapNo: {
      type: String,
      trim: true,
      default: ''
    },
    accountingNo: {
      type: String,
      trim: true,
      default: ''
    },
    odwNo: {
      type: String,
      trim: true,
      default: ''
    },
    tplNotes: {
      type: String,
      trim: true,
      default: ''
    },
    protocolFile: {
      type: attachmentSchema,
      default: null
    },
    checklistFile: {
      type: attachmentSchema,
      default: null
    },
    certificateFile: {
      type: attachmentSchema,
      default: null
    },
    outlayFile: {
      type: attachmentSchema,
      default: null
    },
    nameplateFile: {
      type: attachmentSchema,
      default: null
    },
    photoFile: {
      type: attachmentSchema,
      default: null
    },
    attachmentFile: {
      type: attachmentSchema,
      default: null
    },
    users: [String],
    changes: [changeSchema]
  }, {
    id: false,
    minimize: false
  });

  schema.statics.TOPIC_PREFIX = 'fa.ot';
  schema.statics.PRIVILEGE_PREFIX = 'FA:OT';
  schema.statics.BROWSE_LIMIT = 100;
  schema.statics.STAGES = STAGES;
  schema.statics.SEARCH_PROPS = ['assetName', 'supplier', 'vendorName'];
  schema.statics.USER_PROPS = ['createdBy', 'owner', 'committee'];

  schema.index({createdAt: -1});
  schema.index({updatedAt: -1});
  schema.index({date: -1});
  schema.index({stage: 1});
  schema.index({protocolNo: 1});
  schema.index({documentNo: 1});
  schema.index({inventoryNo: 1});
  schema.index({sapNo: 1});
  schema.index({accountingNo: 1});
  schema.index({costCenter: 1});
  schema.index({vendorNo: 1});
  schema.index({users: 1});
  schema.statics.SEARCH_PROPS.forEach(prop => schema.index({[`${prop}Search`]: 1}));

  schema.pre('save', function(next)
  {
    this.date = this.documentDate || this.protocolDate;

    schema.statics.SEARCH_PROPS.forEach(prop =>
    {
      if (this.isNew || this.isModified(prop))
      {
        this[`${prop}Search`] = this.constructor.prepareSearchText(this[prop]);
      }
    });

    collectUsers(this, schema.statics.USER_PROPS);

    next();
  });

  schema.plugin(lastModifiedPaths);

  schema.statics.prepareSearchText = function(value)
  {
    return transliterate(value, {unknown: ''})
      .replace(/[^A-Za-z0-9]+/g, '')
      .toUpperCase();
  };

  schema.methods.applyChanges = function(input, updatedBy)
  {
    this.updatedAt = new Date();
    this.updatedBy = updatedBy;

    const currentStage = this.stage;
    const comment = input.comment || '';

    input.stage = input.newStage || currentStage;

    if (input.stage !== currentStage)
    {
      const currentI = STAGES.indexOf(currentStage);
      const newI = STAGES.indexOf(input.stage);

      if (newI < currentI || input.stage === 'cancelled')
      {
        this.stageChangedAt[input.stage] = this.updatedAt;
        this.stageChangedBy[input.stage] = this.updatedBy;
      }
      else if (newI > currentI)
      {
        this.stageChangedAt[currentStage] = this.updatedAt;
        this.stageChangedBy[currentStage] = this.updatedBy;
      }
    }

    const changes = this.compareProperties(_.pick(input, STAGE_PROPS[currentStage]));

    if (_.isEmpty(changes) && _.isEmpty(comment))
    {
      return false;
    }

    this.changes.push({
      date: this.updatedAt,
      user: updatedBy,
      data: changes,
      comment
    });

    return true;
  };

  schema.methods.compareProperties = function(input)
  {
    const changes = {};

    _.forEach(input, (value, key) => { this.compareProperty(key, input, changes); });

    return changes;
  };

  schema.methods.compareProperty = function(property, input, changes)
  {
    let oldValue = this[property];
    let newValue = input[property];

    if (_.isObject(oldValue) && _.isFunction(oldValue.toObject))
    {
      oldValue = oldValue.toObject();
    }

    if (_.isObject(newValue) && _.isFunction(newValue.toObject))
    {
      newValue = newValue.toObject();
    }

    if (oldValue instanceof mongoose.Types.ObjectId)
    {
      oldValue = oldValue.toString();
    }

    if (_.isString(newValue))
    {
      newValue = newValue.trim();

      if (/date/i.test(property))
      {
        newValue = new Date(newValue);
      }
    }

    if (deepEqual(newValue, oldValue, {strict: true}))
    {
      return false;
    }

    changes[property] = [oldValue, newValue];
    this[property] = newValue;

    return true;
  };

  schema.methods.canEdit = function(user)
  {
    const privileges = user.privileges || [];

    if (privileges.includes('SUPER')
      || privileges.includes('FA:MANAGE')
      || privileges.includes('FA:OT:MANAGE'))
    {
      return true;
    }

    switch (this.stage)
    {
      case 'protocol':
      case 'authorize':
      case 'document':
        return this.createdBy._id === user._id;

      case 'accept':
        return !!this.owner && this.owner._id === user._id;

      case 'verify':
      case 'record':
        return privileges.includes('FA:OT:' + this.stage);

      case 'finished':
        return privileges.includes('SUPER');

      case 'cancelled':
        return user.login === 'root';
    }

    return false;
  };

  return schema;
};
