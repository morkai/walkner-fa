// Part of <https://miracle.systems/p/walkner-fa> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const moment = require('moment');
const deepEqual = require('deep-equal');
const {transliterate} = require('transliteration');
const lastModifiedPaths = require('h5-mongoose/plugins/lastModifiedPaths');
const userInfoSchema = require('user/models/userInfoSchema');
const arrayToObject = require('util/arrayToObject');
const collectUsers = require('./collectUsers');

exports.name = 'FaOt';

exports.setUp = (app, mongoose) =>
{
  const STAGE_PROPS = {
    protocol: [
      'stage',
      'protocolDate',
      'inventoryNo',
      'serialNo',
      'assetName',
      'lineSymbol',
      'zplx',
      'owner',
      'committee',
      'supplier',
      'protocolFile',
      'photoFile',
      'attachmentFile'
    ],
    authorize: [
      'stage',
      'attachmentFile'
    ],
    document: [
      'stage',
      'documentNo',
      'documentDate',
      'assetName',
      'inventoryNo',
      'serialNo',
      'lineSymbol',
      'zplx',
      'supplier',
      'owner',
      'value',
      'costCenter',
      'vendorNo',
      'vendorName',
      'checklistFile',
      'certificateFile',
      'outlayFile',
      'nameplateFile',
      'photoFile',
      'attachmentFile'
    ],
    verify: [
      'stage',
      'assetName',
      'zplx',
      'inventoryNo',
      'serialNo',
      'evalGroup1',
      'evalGroup5',
      'assetClass',
      'depRate',
      'depKey',
      'economicMethod',
      'fiscalMethod',
      'taxMethod',
      'economicPeriod',
      'fiscalPeriod',
      'taxPeriod',
      'economicDate',
      'fiscalDate',
      'taxDate',
      'transactions',
      'postingDate',
      'tplNotes',
      'hrtFile',
      'attachmentFile'
    ],
    accept: [
      'stage',
      'attachmentFile'
    ],
    record: [
      'stage',
      'assetNo',
      'accountingNo',
      'odwNo',
      'attachmentFile'
    ],
    finished: [
      'protocolDate',
      'documentDate',
      'inventoryNo',
      'serialNo',
      'lineSymbol',
      'assetName',
      'zplx',
      'owner',
      'committee',
      'supplier',
      'vendorNo',
      'vendorName',
      'value',
      'costCenter',
      'evalGroup1',
      'evalGroup5',
      'assetClass',
      'depRate',
      'depKey',
      'economicMethod',
      'fiscalMethod',
      'taxMethod',
      'economicPeriod',
      'fiscalPeriod',
      'taxPeriod',
      'economicDate',
      'fiscalDate',
      'taxDate',
      'transactions',
      'postingDate',
      'assetNo',
      'accountingNo',
      'odwNo',
      'tplNotes',
      'protocolFile',
      'checklistFile',
      'outlayFile',
      'certificateFile',
      'nameplateFile',
      'photoFile',
      'hrtFile',
      'attachmentFile'
    ],
    cancelled: [
      'stage'
    ]
  };
  const STAGES = Object.keys(STAGE_PROPS);

  const attachmentSchema = new mongoose.Schema({
    hash: String,
    type: String,
    size: Number,
    name: String
  }, {
    _id: false
  });

  const zplxSchema = new mongoose.Schema({
    code: {
      type: String,
      match: /^(ZPLX)?[0-9]{1,8}$/
    },
    value: {
      type: Number,
      min: 0
    },
    auc: {
      type: String,
      default: ''
    }
  }, {
    _id: false
  });

  const transactionSchema = new mongoose.Schema({
    type: {
      type: String,
      match: /^[A-Za-z0-9]{3}$/
    },
    amount1: {
      type: Number,
      min: 0,
      default: 0
    },
    amount2: {
      type: Number,
      min: 0,
      default: 0
    }
  }, {
    _id: false
  });

  const changeSchema = new mongoose.Schema({
    date: {
      type: Date,
      required: true
    },
    user: userInfoSchema,
    data: {},
    comment: {
      type: String,
      trim: true,
      default: ''
    }
  }, {
    _id: false,
    minimize: false
  });

  const schema = new mongoose.Schema({
    createdAt: {
      type: Date,
      required: true
    },
    createdBy: {
      type: userInfoSchema,
      required: true
    },
    updatedAt: {
      type: Date,
      default: null
    },
    updatedBy: {
      type: userInfoSchema,
      default: null
    },
    stage: {
      type: String,
      required: true,
      enum: STAGES
    },
    stageChangedAt: arrayToObject(STAGES, Date),
    stageChangedBy: arrayToObject(STAGES, userInfoSchema),
    protocolNeeded: {
      type: Boolean,
      required: true
    },
    commissioningType: {
      type: String,
      required: true,
      enum: [null, 'new-asset', 'inc-asset']
    },
    usageDestination: {
      type: String,
      required: true,
      enum: ['factory', 'external-supplier']
    },
    extendedDep: {
      type: Boolean,
      default: false
    },
    protocolNo: {
      type: String,
      default: ''
    },
    protocolNoInc: {
      type: Number,
      default: 0
    },
    documentNo: {
      type: String,
      default: ''
    },
    documentNoInc: {
      type: Number,
      default: 0
    },
    date: Date,
    protocolDate: {
      type: Date,
      default: null
    },
    documentDate: {
      type: Date,
      default: null
    },
    inventoryNo: {
      type: String,
      trim: true,
      default: ''
    },
    serialNo: {
      type: String,
      trim: true,
      default: ''
    },
    assetName: {
      type: String,
      trim: true,
      default: ''
    },
    assetNameSearch: String,
    lineSymbol: {
      type: String,
      trim: true,
      default: ''
    },
    zplx: [zplxSchema],
    owner: {
      type: userInfoSchema,
      default: null
    },
    committee: [userInfoSchema],
    supplier: {
      type: String,
      trim: true,
      default: ''
    },
    supplierSearch: String,
    costCenter: {
      type: String,
      ref: 'FaCostCenter',
      default: null
    },
    evalGroup1: {
      type: String,
      trim: true,
      default: ''
    },
    evalGroup5: {
      type: String,
      trim: true,
      default: ''
    },
    assetClass: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'FaAssetClass',
      default: null
    },
    depRate: {
      type: Number,
      min: 0,
      max: 100,
      default: 0
    },
    depKey: {
      type: String,
      trim: true,
      default: ''
    },
    economicMethod: {
      type: String,
      trim: true,
      default: ''
    },
    fiscalMethod: {
      type: String,
      trim: true,
      default: ''
    },
    taxMethod: {
      type: String,
      trim: true,
      default: ''
    },
    economicPeriod: {
      type: Number,
      min: 0,
      max: 1200,
      default: 0
    },
    fiscalPeriod: {
      type: Number,
      min: 0,
      max: 1200,
      default: 0
    },
    taxPeriod: {
      type: Number,
      min: 0,
      max: 1200,
      default: 0
    },
    economicDate: {
      type: Date,
      default: null
    },
    fiscalDate: {
      type: Date,
      default: null
    },
    taxDate: {
      type: Date,
      default: null
    },
    value: {
      type: Number,
      min: 0,
      default: 0
    },
    transactions: [transactionSchema],
    postingDate: {
      type: Date,
      default: null
    },
    vendorNo: {
      type: String,
      trim: true,
      default: ''
    },
    vendorName: {
      type: String,
      trim: true,
      default: ''
    },
    vendorNameSearch: String,
    assetNo: {
      type: String,
      trim: true,
      default: ''
    },
    accountingNo: {
      type: String,
      trim: true,
      default: ''
    },
    odwNo: {
      type: String,
      trim: true,
      default: ''
    },
    tplNotes: {
      type: String,
      trim: true,
      default: ''
    },
    protocolFile: {
      type: attachmentSchema,
      default: null
    },
    checklistFile: {
      type: attachmentSchema,
      default: null
    },
    certificateFile: {
      type: attachmentSchema,
      default: null
    },
    outlayFile: {
      type: attachmentSchema,
      default: null
    },
    nameplateFile: {
      type: attachmentSchema,
      default: null
    },
    photoFile: {
      type: attachmentSchema,
      default: null
    },
    hrtFile: {
      type: attachmentSchema,
      default: null
    },
    attachmentFile: {
      type: attachmentSchema,
      default: null
    },
    users: [String],
    changes: [changeSchema]
  }, {
    id: false,
    minimize: false
  });

  schema.statics.TOPIC_PREFIX = 'fa.ot';
  schema.statics.PRIVILEGE_PREFIX = 'FA:OT';
  schema.statics.BROWSE_LIMIT = 100;
  schema.statics.STAGES = STAGES;
  schema.statics.SEARCH_PROPS = ['assetName', 'supplier', 'vendorName'];
  schema.statics.USER_PROPS = ['createdBy', 'owner', 'committee'];

  schema.index({createdAt: -1});
  schema.index({updatedAt: -1});
  schema.index({date: -1});
  schema.index({stage: 1});
  schema.index({protocolNo: 1});
  schema.index({documentNo: 1});
  schema.index({inventoryNo: 1});
  schema.index({assetNo: 1});
  schema.index({accountingNo: 1});
  schema.index({costCenter: 1});
  schema.index({vendorNo: 1});
  schema.index({users: 1});
  schema.index({commissioningType: 1});
  schema.statics.SEARCH_PROPS.forEach(prop => schema.index({[`${prop}Search`]: 1}));

  schema.pre('save', function(next)
  {
    this.date = this.documentDate || this.protocolDate;

    schema.statics.SEARCH_PROPS.forEach(prop =>
    {
      if (this.isNew || this.isModified(prop))
      {
        this[`${prop}Search`] = this.constructor.prepareSearchText(this[prop]);
      }
    });

    collectUsers(this, schema.statics.USER_PROPS);

    next();
  });

  schema.plugin(lastModifiedPaths);

  schema.statics.prepareSearchText = function(value)
  {
    return transliterate(value, {unknown: ''})
      .replace(/[^A-Za-z0-9]+/g, '')
      .toUpperCase();
  };

  schema.methods.applyChanges = function(input, updatedBy)
  {
    this.updatedAt = new Date();
    this.updatedBy = updatedBy;

    const currentStage = this.stage;
    const comment = input.comment || '';

    input.stage = input.newStage || currentStage;

    if (input.stage !== currentStage)
    {
      const currentI = STAGES.indexOf(currentStage);
      const newI = STAGES.indexOf(input.stage);

      if (newI < currentI || input.stage === 'cancelled')
      {
        this.stageChangedAt[input.stage] = this.updatedAt;
        this.stageChangedBy[input.stage] = this.updatedBy;
      }
      else if (newI > currentI)
      {
        this.stageChangedAt[currentStage] = this.updatedAt;
        this.stageChangedBy[currentStage] = this.updatedBy;
      }
    }

    const changes = this.compareProperties(_.pick(input, STAGE_PROPS[currentStage]));

    if (_.isEmpty(changes) && _.isEmpty(comment))
    {
      return false;
    }

    this.changes.push({
      date: this.updatedAt,
      user: updatedBy,
      data: changes,
      comment
    });

    return true;
  };

  schema.methods.compareProperties = function(input)
  {
    const changes = {};

    _.forEach(input, (value, key) => { this.compareProperty(key, input, changes); });

    return changes;
  };

  schema.methods.compareProperty = function(property, input, changes)
  {
    let oldValue = this[property];
    let newValue = input[property];

    if (_.isObject(oldValue) && _.isFunction(oldValue.toObject))
    {
      oldValue = oldValue.toObject();
    }

    if (_.isObject(newValue) && _.isFunction(newValue.toObject))
    {
      newValue = newValue.toObject();
    }

    if (oldValue instanceof mongoose.Types.ObjectId)
    {
      oldValue = oldValue.toString();
    }

    if (_.isString(newValue))
    {
      newValue = newValue.trim();

      if (/date/i.test(property))
      {
        newValue = new Date(newValue);
      }
    }

    if (deepEqual(newValue, oldValue, {strict: true}))
    {
      return false;
    }

    changes[property] = [oldValue, newValue];
    this[property] = newValue;

    return true;
  };

  schema.methods.canEdit = function(user)
  {
    const privileges = user.privileges || [];

    if (privileges.includes('SUPER')
      || privileges.includes('FA:MANAGE')
      || privileges.includes('FA:OT:MANAGE'))
    {
      return true;
    }

    switch (this.stage)
    {
      case 'protocol':
      case 'authorize':
      case 'document':
        return this.createdBy._id === user._id;

      case 'accept':
        return !!this.owner && this.owner._id === user._id;

      case 'verify':
      case 'record':
        return privileges.includes(`FA:OT:${this.stage}`);

      case 'finished':
        return privileges.includes('SUPER');

      case 'cancelled':
        return user.login === 'root';
    }

    return false;
  };

  schema.methods.toReqTpl = async function()
  {
    const assetClass = !this.assetClass
      ? null
      : (await mongoose.model('FaAssetClass').findById(this.assetClass).lean().exec());

    const transactions = this.transactions.length ? this.transactions : [{type: '', amount1: 0, amount2: 0}];

    return {
      reqTplId: `ot.${this.commissioningType}`,
      valueColumns: transactions.length,
      protocolNo: {
        type: 'string',
        value: transactions.map(() => this.protocolNo)
      },
      documentNo: {
        type: 'string',
        value: transactions.map(() => this.documentNo)
      },
      protocolDate: {
        type: 'string',
        value: transactions.map(() => this.protocolDate ? moment.utc(this.protocolDate).format('YYYY-MM-DD') : '')
      },
      documentDate: {
        type: 'string',
        value: transactions.map(() => this.documentDate ? moment.utc(this.documentDate).format('YYYY-MM-DD') : '')
      },
      inventoryNo: {
        type: 'string',
        value: transactions.map(() => this.inventoryNo)
      },
      serialNo: {
        type: 'string',
        value: transactions.map(() => this.serialNo)
      },
      assetName: {
        type: 'string',
        value: transactions.map(() => this.assetName)
      },
      lineSymbol: {
        type: 'string',
        value: transactions.map(() => this.lineSymbol)
      },
      zplx: {
        type: 'string',
        value: transactions.map(() => this.zplx.length ? this.zplx[0].code : '')
      },
      auc: {
        type: 'string',
        value: transactions.map(() => this.zplx.length ? this.zplx[0].auc : '')
      },
      owner: {
        type: 'string',
        value: transactions.map(() => this.owner ? this.owner.label : '')
      },
      committee: {
        type: 'string',
        value: transactions.map(() => this.committee.map(u => u.label).join(', '))
      },
      supplier: {
        type: 'string',
        value: transactions.map(() => this.supplier)
      },
      costCenter: {
        type: 'string',
        value: transactions.map(() => this.costCenter)
      },
      evalGroup1: {
        type: 'string',
        value: transactions.map(() => this.evalGroup1)
      },
      evalGroup5: {
        type: 'string',
        value: transactions.map(() => this.evalGroup5)
      },
      assetClass: {
        type: 'string',
        value: transactions.map(() => assetClass ? assetClass.name : '')
      },
      depRate: {
        type: 'decimal',
        value: transactions.map(() => this.depRate)
      },
      depKey: {
        type: 'string',
        value: transactions.map(() => this.depKey)
      },
      economicMethod: {
        type: 'string',
        value: transactions.map(() => this.economicMethod)
      },
      fiscalMethod: {
        type: 'string',
        value: transactions.map(() => this.fiscalMethod)
      },
      taxMethod: {
        type: 'string',
        value: transactions.map(() => this.taxMethod)
      },
      economicPeriodY: {
        type: 'string',
        value: transactions.map(() => tplYearsA(Math.floor(this.economicPeriod / 12)))
      },
      economicPeriodM: {
        type: 'string',
        value: transactions.map(() => tplMonthsA(this.economicPeriod % 12))
      },
      fiscalPeriodY: {
        type: 'string',
        value: transactions.map(() => tplYearsB(Math.floor(this.fiscalPeriod / 12)))
      },
      fiscalPeriodM: {
        type: 'string',
        value: transactions.map(() => tplMonthsB(this.fiscalPeriod % 12))
      },
      taxPeriodY: {
        type: 'string',
        value: transactions.map(() => tplYearsB(Math.floor(this.taxPeriod / 12)))
      },
      taxPeriodM: {
        type: 'string',
        value: transactions.map(() => tplMonthsB(this.taxPeriod % 12))
      },
      economicDate: {
        type: 'string',
        value: transactions.map(() => this.economicDate ? moment.utc(this.economicDate).format('YYYY-MM-DD') : '')
      },
      fiscalDate: {
        type: 'string',
        value: transactions.map(() => this.fiscalDate ? moment.utc(this.fiscalDate).format('YYYY-MM-DD') : '')
      },
      taxDate: {
        type: 'string',
        value: transactions.map(() => this.taxDate ? moment.utc(this.taxDate).format('YYYY-MM-DD') : '')
      },
      value: {
        type: 'decimal',
        value: transactions.map(() => this.value)
      },
      transactionType: {
        type: 'string',
        value: transactions.map(t => t.type)
      },
      transactionAmount1: {
        type: 'string',
        value: transactions.map(t => t.amount1)
      },
      transactionAmount2: {
        type: 'string',
        value: transactions.map(t => t.amount2)
      },
      postingDate: {
        type: 'string',
        value: transactions.map(() => this.postingDate ? moment.utc(this.postingDate).format('YYYY-MM-DD') : '')
      },
      vendorNo: {
        type: 'string',
        value: transactions.map(() => this.vendorNo)
      },
      vendorName: {
        type: 'string',
        value: transactions.map(() => this.vendorName)
      },
      assetNo: {
        type: 'string',
        value: transactions.map(() => this.assetNo)
      },
      accountingNo: {
        type: 'string',
        value: transactions.map(() => this.accountingNo)
      },
      odwNo: {
        type: 'string',
        value: transactions.map(() => this.odwNo)
      },
      tplNotes: {
        type: 'string',
        value: transactions.map(() => this.tplNotes)
      }
    };
  };

  function tplYearsA(n)
  {
    if (n <= 0)
    {
      return '0';
    }

    if (n === 1)
    {
      return '01 - Year';
    }

    return `${n.toString().padStart(2, '0')} - Years`;
  }

  function tplYearsB(n)
  {
    return `${n} - Years`;
  }

  function tplMonthsA(n)
  {
    if (n <= 0)
    {
      return '0';
    }

    if (n === 1 || n === 8)
    {
      return `0${n} - Month`;
    }

    return `${n.toString().padStart(2, '0')} - Months`;
  }

  function tplMonthsB(n)
  {
    return `${n} - Months`;
  }

  return schema;
};
