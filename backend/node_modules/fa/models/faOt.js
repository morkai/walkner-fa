// Part of <https://miracle.systems/p/walkner-fa> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const moment = require('moment');
const deepEqual = require('deep-equal');
const {transliterate} = require('transliteration');
const lastModifiedPaths = require('h5-mongoose/plugins/lastModifiedPaths');
const userInfoSchema = require('user/models/userInfoSchema');
const arrayToObject = require('util/arrayToObject');
const jsonDeepEqual = require('util/jsonDeepEqual');
const collectUsers = require('./collectUsers');

exports.name = 'FaOt';

exports.setUp = (app, mongoose) =>
{
  const STAGE_PROPS = {
    protocol: [
      'stage',
      'protocolDate',
      'zplx',
      'committee',
      'protocolFile',
      'attachmentFile',
      'assets'
    ],
    authorize: [
      'stage',
      'attachmentFile'
    ],
    document: [
      'stage',
      'documentNo',
      'documentDate',
      'zplx',
      'checklistFile',
      'certificateFile',
      'outlayFile',
      'nameplateFile',
      'attachmentFile',
      'assets'
    ],
    verify: [
      'stage',
      'zplx',
      'postingDate',
      'hrtFile',
      'attachmentFile',
      'assets'
    ],
    accept: [
      'stage',
      'attachmentFile'
    ],
    record: [
      'stage',
      'attachmentFile',
      'assets'
    ],
    finished: [
      'protocolDate',
      'documentDate',
      'zplx',
      'committee',
      'postingDate',
      'protocolFile',
      'checklistFile',
      'outlayFile',
      'certificateFile',
      'nameplateFile',
      'hrtFile',
      'attachmentFile',
      'assets'
    ],
    cancelled: [
      'stage'
    ]
  };
  const STAGE_ASSET_PROPS = {
    protocol: [
      'inventoryNo',
      'serialNo',
      'assetName',
      'lineSymbol',
      'owner',
      'supplier',
      'photoFile'
    ],
    authorize: [],
    document: [
      'assetName',
      'inventoryNo',
      'serialNo',
      'lineSymbol',
      'supplier',
      'owner',
      'value',
      'costCenter',
      'vendorNo',
      'vendorName',
      'photoFile'
    ],
    verify: [
      'assetName',
      'inventoryNo',
      'serialNo',
      'evalGroup1',
      'evalGroup5',
      'assetClass',
      'depRate',
      'depKey',
      'economicMethod',
      'fiscalMethod',
      'taxMethod',
      'economicPeriod',
      'fiscalPeriod',
      'taxPeriod',
      'economicDate',
      'fiscalDate',
      'taxDate',
      'transactions',
      'tplNotes'
    ],
    accept: [],
    record: [
      'assetNo',
      'accountingNo',
      'odwNo'
    ],
    finished: [
      'inventoryNo',
      'serialNo',
      'lineSymbol',
      'assetName',
      'owner',
      'supplier',
      'vendorNo',
      'vendorName',
      'value',
      'costCenter',
      'evalGroup1',
      'evalGroup5',
      'assetClass',
      'depRate',
      'depKey',
      'economicMethod',
      'fiscalMethod',
      'taxMethod',
      'economicPeriod',
      'fiscalPeriod',
      'taxPeriod',
      'economicDate',
      'fiscalDate',
      'taxDate',
      'transactions',
      'assetNo',
      'accountingNo',
      'odwNo',
      'tplNotes',
      'photoFile'
    ],
    cancelled: []
  };
  const STAGES = Object.keys(STAGE_PROPS);

  const attachmentSchema = new mongoose.Schema({
    hash: String,
    type: String,
    size: Number,
    name: String
  }, {
    _id: false
  });

  const zplxSchema = new mongoose.Schema({
    code: {
      type: String,
      match: /^(ZPLX)?[0-9]{1,8}$/
    },
    value: {
      type: Number,
      min: 0
    },
    auc: {
      type: String,
      default: ''
    }
  }, {
    _id: false
  });

  const transactionSchema = new mongoose.Schema({
    type: {
      type: String,
      match: /^[A-Za-z0-9]{3}$/
    },
    amount1: {
      type: Number,
      min: 0,
      default: 0
    },
    amount2: {
      type: Number,
      min: 0,
      default: 0
    }
  }, {
    _id: false
  });

  const assetSchema = new mongoose.Schema({
    _id: String,
    inventoryNo: {
      type: String,
      trim: true,
      default: ''
    },
    serialNo: {
      type: String,
      trim: true,
      default: ''
    },
    assetName: {
      type: String,
      trim: true,
      default: ''
    },
    assetNameSearch: String,
    lineSymbol: {
      type: String,
      trim: true,
      default: ''
    },
    owner: {
      type: userInfoSchema,
      default: null
    },
    supplier: {
      type: String,
      trim: true,
      default: ''
    },
    supplierSearch: String,
    costCenter: {
      type: String,
      ref: 'FaCostCenter',
      default: null
    },
    evalGroup1: {
      type: String,
      trim: true,
      default: ''
    },
    evalGroup5: {
      type: String,
      trim: true,
      default: ''
    },
    assetClass: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'FaAssetClass',
      default: null
    },
    depRate: {
      type: Number,
      min: 0,
      max: 100,
      default: 0
    },
    depKey: {
      type: String,
      trim: true,
      default: ''
    },
    economicMethod: {
      type: String,
      trim: true,
      default: ''
    },
    fiscalMethod: {
      type: String,
      trim: true,
      default: ''
    },
    taxMethod: {
      type: String,
      trim: true,
      default: ''
    },
    economicPeriod: {
      type: Number,
      min: 0,
      max: 1200,
      default: 0
    },
    fiscalPeriod: {
      type: Number,
      min: 0,
      max: 1200,
      default: 0
    },
    taxPeriod: {
      type: Number,
      min: 0,
      max: 1200,
      default: 0
    },
    economicDate: {
      type: Date,
      default: null
    },
    fiscalDate: {
      type: Date,
      default: null
    },
    taxDate: {
      type: Date,
      default: null
    },
    value: {
      type: Number,
      min: 0,
      default: 0
    },
    transactions: [transactionSchema],
    vendorNo: {
      type: String,
      trim: true,
      default: ''
    },
    vendorName: {
      type: String,
      trim: true,
      default: ''
    },
    vendorNameSearch: String,
    assetNo: {
      type: String,
      trim: true,
      default: ''
    },
    accountingNo: {
      type: String,
      trim: true,
      default: ''
    },
    odwNo: {
      type: String,
      trim: true,
      default: ''
    },
    tplNotes: {
      type: String,
      trim: true,
      default: ''
    },
    photoFile: {
      type: attachmentSchema,
      default: null
    }
  }, {
    _id: false
  });

  const changeSchema = new mongoose.Schema({
    date: {
      type: Date,
      required: true
    },
    user: userInfoSchema,
    data: {},
    comment: {
      type: String,
      trim: true,
      default: ''
    }
  }, {
    _id: false,
    minimize: false
  });

  const schema = new mongoose.Schema({
    createdAt: {
      type: Date,
      required: true
    },
    createdBy: {
      type: userInfoSchema,
      required: true
    },
    updatedAt: {
      type: Date,
      default: null
    },
    updatedBy: {
      type: userInfoSchema,
      default: null
    },
    stage: {
      type: String,
      required: true,
      enum: STAGES
    },
    stageChangedAt: arrayToObject(STAGES, Date),
    stageChangedBy: arrayToObject(STAGES, userInfoSchema),
    protocolNeeded: {
      type: Boolean,
      required: true
    },
    commissioningType: {
      type: String,
      required: true,
      enum: [null, 'new-asset', 'inc-asset']
    },
    usageDestination: {
      type: String,
      required: true,
      enum: ['factory', 'external-supplier']
    },
    extendedDep: {
      type: Boolean,
      default: false
    },
    protocolNo: {
      type: String,
      default: ''
    },
    protocolNoInc: {
      type: Number,
      default: 0
    },
    documentNo: {
      type: String,
      default: ''
    },
    documentNoInc: {
      type: Number,
      default: 0
    },
    date: Date,
    protocolDate: {
      type: Date,
      default: null
    },
    documentDate: {
      type: Date,
      default: null
    },
    zplx: [zplxSchema],
    committee: [userInfoSchema],
    assets: {
      type: [assetSchema],
      required: true
    },
    postingDate: {
      type: Date,
      default: null
    },
    protocolFile: {
      type: attachmentSchema,
      default: null
    },
    checklistFile: {
      type: attachmentSchema,
      default: null
    },
    certificateFile: {
      type: attachmentSchema,
      default: null
    },
    outlayFile: {
      type: attachmentSchema,
      default: null
    },
    nameplateFile: {
      type: attachmentSchema,
      default: null
    },
    hrtFile: {
      type: attachmentSchema,
      default: null
    },
    attachmentFile: {
      type: attachmentSchema,
      default: null
    },
    users: [String],
    changes: [changeSchema]
  }, {
    id: false,
    minimize: false
  });

  schema.statics.TOPIC_PREFIX = 'fa.ot';
  schema.statics.PRIVILEGE_PREFIX = 'FA:OT';
  schema.statics.BROWSE_LIMIT = 100;
  schema.statics.STAGES = STAGES;
  schema.statics.SEARCH_PROPS = [];
  schema.statics.SEARCH_ASSET_PROPS = ['assetName', 'supplier', 'vendorName'];
  schema.statics.USER_PROPS = ['createdBy', 'committee'];
  schema.statics.USER_ASSET_PROPS = ['owner'];

  schema.index({createdAt: -1});
  schema.index({updatedAt: -1});
  schema.index({date: -1});
  schema.index({stage: 1});
  schema.index({protocolNo: 1});
  schema.index({documentNo: 1});
  schema.index({commissioningType: 1});
  schema.index({users: 1});
  schema.index({'assets.inventoryNo': 1});
  schema.index({'assets.assetNo': 1});
  schema.index({'assets.accountingNo': 1});
  schema.index({'assets.costCenter': 1});
  schema.index({'assets.vendorNo': 1});
  schema.statics.SEARCH_PROPS.forEach(prop => schema.index({[`${prop}Search`]: 1}));
  schema.statics.SEARCH_ASSET_PROPS.forEach(prop => schema.index({[`assets.${prop}Search`]: 1}));

  schema.pre('save', function(next)
  {
    this.date = this.documentDate || this.protocolDate;

    schema.statics.SEARCH_PROPS.forEach(prop =>
    {
      if (this.isNew || this.isModified(prop))
      {
        this[`${prop}Search`] = this.constructor.prepareSearchText(this[prop]);
      }
    });

    if (this.isNew || this.isModified('assets'))
    {
      this.assets.forEach(asset =>
      {
        schema.statics.SEARCH_ASSET_PROPS.forEach(prop =>
        {
          asset[`${prop}Search`] = this.constructor.prepareSearchText(asset[prop]);
        });
      });
    }

    const users = new Set();

    collectUsers(this, schema.statics.USER_PROPS);
    this.assets.forEach(asset => collectUsers(asset, schema.statics.USER_ASSET_PROPS));

    this.users = Array.from(users);

    next();
  });

  schema.plugin(lastModifiedPaths);

  schema.statics.prepareSearchText = function(value)
  {
    return transliterate(value, {unknown: ''})
      .replace(/[^A-Za-z0-9]+/g, '')
      .toUpperCase();
  };

  schema.methods.applyChanges = function(input, updatedBy)
  {
    this.updatedAt = new Date();
    this.updatedBy = updatedBy;

    const currentStage = this.stage;
    const comment = input.comment || '';

    input.stage = input.newStage || currentStage;

    if (input.stage !== currentStage)
    {
      const currentI = STAGES.indexOf(currentStage);
      const newI = STAGES.indexOf(input.stage);

      if (newI < currentI || input.stage === 'cancelled')
      {
        this.stageChangedAt[input.stage] = this.updatedAt;
        this.stageChangedBy[input.stage] = this.updatedBy;
      }
      else if (newI > currentI)
      {
        this.stageChangedAt[currentStage] = this.updatedAt;
        this.stageChangedBy[currentStage] = this.updatedBy;
      }
    }

    input = _.pick(input, STAGE_PROPS[currentStage]);

    if (Array.isArray(input.assets))
    {
      input.assets = input.assets.map(asset => _.pick(asset, ['_id', ...STAGE_ASSET_PROPS[currentStage]]));
    }

    const changes = this.compareProperties(input);

    if (_.isEmpty(changes) && _.isEmpty(comment))
    {
      return false;
    }

    this.changes.push({
      date: this.updatedAt,
      user: updatedBy,
      data: changes,
      comment
    });

    return true;
  };

  schema.methods.compareProperties = function(input)
  {
    const changes = {};

    _.forEach(input, (value, key) => { this.compareProperty(key, input, changes); });

    return changes;
  };

  schema.methods.compareProperty = function(property, input, changes)
  {
    let oldValue = this[property];
    let newValue = input[property];

    if (_.isObject(oldValue) && _.isFunction(oldValue.toObject))
    {
      oldValue = oldValue.toObject();
    }

    if (_.isObject(newValue) && _.isFunction(newValue.toObject))
    {
      newValue = newValue.toObject();
    }

    if (property === 'assets')
    {
      return this.compareAssetsProperty(oldValue, newValue, changes);
    }

    if (oldValue instanceof mongoose.Types.ObjectId)
    {
      oldValue = oldValue.toString();
    }

    if (_.isString(newValue))
    {
      newValue = newValue.trim();

      if (/date/i.test(property))
      {
        newValue = new Date(newValue);
      }
    }

    if (deepEqual(newValue, oldValue, {strict: true}))
    {
      return false;
    }

    changes[property] = [oldValue, newValue];
    this[property] = newValue;

    return true;
  };

  schema.methods.compareAssetsProperty = function(oldAssetList, newAssetList, changes)
  {
    if (!Array.isArray(newAssetList))
    {
      throw app.createError('Invalid new assets list.', 'INPUT', 400);
    }

    const oldAssetMap = new Map();
    const newAssetMap = new Map();

    oldAssetList.forEach((asset, i) => oldAssetMap.set(asset._id, {asset, i}));
    newAssetList.forEach(asset => newAssetMap.set(asset._id, asset));

    const added = [];
    const edited = [];
    const deleted = [];
    const assets = [];

    newAssetMap.forEach(newData =>
    {
      const {asset: oldAsset, i} = oldAssetMap.get(newData._id) || {asset: null, i: -1};

      if (!oldAsset)
      {
        added.push({_i: assets.length, ...newData});
        assets.push(newData);

        return;
      }

      oldAssetMap.delete(newData._id);

      const newAsset = {...oldAsset, ...newData};
      const edit = {_i: i, _id: newAsset._id, old: {}};
      let different = false;

      Object.keys(newData).forEach(property =>
      {
        let oldValue = oldAsset[property];
        let newValue = newAsset[property];

        if (oldValue instanceof mongoose.Types.ObjectId)
        {
          oldValue = oldValue.toString();
        }

        if (_.isString(newValue))
        {
          newValue = newValue.trim();

          if (/date/i.test(property))
          {
            newValue = new Date(newValue);
          }
        }

        if (jsonDeepEqual(newValue, oldValue))
        {
          return;
        }

        edit[property] = newValue;
        edit.old[property] = oldValue;
        different = true;
      });

      if (different)
      {
        edited.push(edit);
        assets.push(newAsset);
      }
      else
      {
        assets.push(oldAsset);
      }
    });

    oldAssetMap.forEach(({asset, i}) => deleted.push({_i: i, ...asset}));

    if (!added.length && !edited.length && !deleted.length)
    {
      return false;
    }

    changes.assets = {added, edited, deleted};
    this.assets = assets;

    return true;
  };

  schema.methods.canEdit = function(user)
  {
    const privileges = user.privileges || [];

    if (privileges.includes('SUPER')
      || privileges.includes('FA:MANAGE')
      || privileges.includes('FA:OT:MANAGE'))
    {
      return true;
    }

    switch (this.stage)
    {
      case 'protocol':
      case 'authorize':
      case 'document':
        return this.createdBy._id === user._id;

      case 'accept':
        return !!this.owner && this.owner._id === user._id;

      case 'verify':
      case 'record':
        return privileges.includes(`FA:OT:${this.stage}`);

      case 'finished':
        return privileges.includes('SUPER');

      case 'cancelled':
        return user.login === 'root';
    }

    return false;
  };

  schema.methods.toReqTpl = async function()
  {
    const assetClassMap = {};
    const valueColumns = [];

    this.assets.forEach(asset =>
    {
      const assetClass = asset.assetClass ? asset.assetClass.toString() : null;

      if (assetClass)
      {
        assetClassMap[assetClass] = assetClass;
      }

      if (!asset.transactions.length)
      {
        valueColumns.push({d: this, a: asset, t: [{type: '', amount1: 0, amount2: 0}]});
      }
      else
      {
        asset.transactions.forEach(transaction =>
        {
          valueColumns.push({d: this, a: asset, t: transaction});
        });
      }
    });

    const assetClassList = await mongoose.model('FaAssetClass')
      .find({_id: {$in: this.assets.map(a => a.assetClass)}})
      .lean()
      .exec();

    assetClassList.forEach(assetClass =>
    {
      assetClassMap[assetClass._id] = assetClass.name;
    });

    return {
      reqTplId: `ot.${this.commissioningType}`,
      valueColumns: valueColumns.length,
      protocolNo: {
        type: 'string',
        value: valueColumns.map(({d}) => d.protocolNo)
      },
      documentNo: {
        type: 'string',
        value: valueColumns.map(({d}) => d.documentNo)
      },
      protocolDate: {
        type: 'string',
        value: valueColumns.map(({d}) => d.protocolDate ? moment.utc(d.protocolDate).format('YYYY-MM-DD') : '')
      },
      documentDate: {
        type: 'string',
        value: valueColumns.map(({d}) => d.documentDate ? moment.utc(d.documentDate).format('YYYY-MM-DD') : '')
      },
      inventoryNo: {
        type: 'string',
        value: valueColumns.map(({a}) => a.inventoryNo)
      },
      serialNo: {
        type: 'string',
        value: valueColumns.map(({a}) => a.serialNo)
      },
      assetName: {
        type: 'string',
        value: valueColumns.map(({a}) => a.assetName)
      },
      lineSymbol: {
        type: 'string',
        value: valueColumns.map(({a}) => a.lineSymbol)
      },
      zplx: {
        type: 'string',
        value: valueColumns.map(({d}) => d.zplx.length ? d.zplx[0].code : '')
      },
      auc: {
        type: 'string',
        value: valueColumns.map(({d}) => d.zplx.length ? d.zplx[0].auc : '')
      },
      owner: {
        type: 'string',
        value: valueColumns.map(({a}) => a.owner ? a.owner.label : '')
      },
      committee: {
        type: 'string',
        value: valueColumns.map(({d}) => d.committee.map(u => u.label).join(', '))
      },
      supplier: {
        type: 'string',
        value: valueColumns.map(({a}) => a.supplier)
      },
      costCenter: {
        type: 'string',
        value: valueColumns.map(({a}) => a.costCenter)
      },
      evalGroup1: {
        type: 'string',
        value: valueColumns.map(({a}) => a.evalGroup1)
      },
      evalGroup5: {
        type: 'string',
        value: valueColumns.map(({a}) => a.evalGroup5)
      },
      assetClass: {
        type: 'string',
        value: valueColumns.map(({a}) => assetClassMap[a.assetClass] || '')
      },
      depRate: {
        type: 'decimal',
        value: valueColumns.map(({a}) => a.depRate)
      },
      depKey: {
        type: 'string',
        value: valueColumns.map(({a}) => a.depKey)
      },
      economicMethod: {
        type: 'string',
        value: valueColumns.map(({a}) => a.economicMethod)
      },
      fiscalMethod: {
        type: 'string',
        value: valueColumns.map(({a}) => a.fiscalMethod)
      },
      taxMethod: {
        type: 'string',
        value: valueColumns.map(({a}) => a.taxMethod)
      },
      economicPeriodY: {
        type: 'string',
        value: valueColumns.map(({a}) => tplYearsA(Math.floor(a.economicPeriod / 12)))
      },
      economicPeriodM: {
        type: 'string',
        value: valueColumns.map(({a}) => tplMonthsA(a.economicPeriod % 12))
      },
      fiscalPeriodY: {
        type: 'string',
        value: valueColumns.map(({a}) => tplYearsB(Math.floor(a.fiscalPeriod / 12)))
      },
      fiscalPeriodM: {
        type: 'string',
        value: valueColumns.map(({a}) => tplMonthsB(a.fiscalPeriod % 12))
      },
      taxPeriodY: {
        type: 'string',
        value: valueColumns.map(({a}) => tplYearsB(Math.floor(a.taxPeriod / 12)))
      },
      taxPeriodM: {
        type: 'string',
        value: valueColumns.map(({a}) => tplMonthsB(a.taxPeriod % 12))
      },
      economicDate: {
        type: 'string',
        value: valueColumns.map(({a}) => a.economicDate ? moment.utc(a.economicDate).format('YYYY-MM-DD') : '')
      },
      fiscalDate: {
        type: 'string',
        value: valueColumns.map(({a}) => a.fiscalDate ? moment.utc(a.fiscalDate).format('YYYY-MM-DD') : '')
      },
      taxDate: {
        type: 'string',
        value: valueColumns.map(({a}) => a.taxDate ? moment.utc(a.taxDate).format('YYYY-MM-DD') : '')
      },
      value: {
        type: 'decimal',
        value: valueColumns.map(({a}) => a.value)
      },
      transactionType: {
        type: 'string',
        value: valueColumns.map(({t}) => t.type)
      },
      transactionAmount1: {
        type: 'string',
        value: valueColumns.map(({t}) => t.amount1)
      },
      transactionAmount2: {
        type: 'string',
        value: valueColumns.map(({t}) => t.amount2)
      },
      postingDate: {
        type: 'string',
        value: valueColumns.map(({d}) => d.postingDate ? moment.utc(d.postingDate).format('YYYY-MM-DD') : '')
      },
      vendorNo: {
        type: 'string',
        value: valueColumns.map(({a}) => a.vendorNo)
      },
      vendorName: {
        type: 'string',
        value: valueColumns.map(({a}) => a.vendorName)
      },
      assetNo: {
        type: 'string',
        value: valueColumns.map(({a}) => a.assetNo)
      },
      accountingNo: {
        type: 'string',
        value: valueColumns.map(({a}) => a.accountingNo)
      },
      odwNo: {
        type: 'string',
        value: valueColumns.map(({a}) => a.odwNo)
      },
      tplNotes: {
        type: 'string',
        value: valueColumns.map(({a}) => a.tplNotes)
      }
    };
  };

  function tplYearsA(n)
  {
    if (n <= 0)
    {
      return '0';
    }

    if (n === 1)
    {
      return '01 - Year';
    }

    return `${n.toString().padStart(2, '0')} - Years`;
  }

  function tplYearsB(n)
  {
    return `${n} - Years`;
  }

  function tplMonthsA(n)
  {
    if (n <= 0)
    {
      return '0';
    }

    if (n === 1 || n === 8)
    {
      return `0${n} - Month`;
    }

    return `${n.toString().padStart(2, '0')} - Months`;
  }

  function tplMonthsB(n)
  {
    return `${n} - Months`;
  }

  return schema;
};
