// Part of <https://miracle.systems/p/walkner-fa> licensed under <CC BY-NC-SA 4.0>

'use strict';

const {promisify} = require('util');
const os = require('os');
const path = require('path');
const fs = require('fs-extra');
const crypto = require('crypto');
const exec = promisify(require('child_process').exec);

exports.name = 'FaReqTpl';

exports.setUp = (app, mongoose) =>
{
  const attachmentSchema = new mongoose.Schema({
    hash: String,
    type: String,
    size: Number,
    name: String
  }, {
    _id: false
  });

  const cellSchema = new mongoose.Schema({
    target: String,
    value: String
  }, {
    _id: false
  });

  const schema = new mongoose.Schema({
    _id: String,
    worksheet: {
      type: String,
      required: true,
      trim: true
    },
    inputFile: attachmentSchema,
    outputFileName: String,
    cells: [cellSchema]
  }, {
    id: false,
    minimize: false
  });

  schema.statics.TOPIC_PREFIX = 'fa.reqTpls';
  schema.statics.BROWSE_LIMIT = 0;

  schema.statics.prepareOutputFileName = function(outputFileName, doc)
  {
    let month;
    let year;

    if (doc.documentDate)
    {
      month = doc.documentDate.getUTCMonth();
      year = doc.documentDate.getUTCFullYear();
    }
    else if (doc.protocolDate)
    {
      month = doc.protocolDate.getUTCMonth();
      year = doc.protocolDate.getUTCFullYear();
    }
    else
    {
      const now = new Date();

      month = now.getMonth();
      year = now.getFullYear();
    }


    return outputFileName
      .replace('{DOCUMENT_NO}', (doc.documentNo || '').replace(/\//g, '-'))
      .replace('{PROTOCOL_NO}', (doc.protocolNo || '').replace(/\//g, '-'))
      .replace('{INVENTORY_NO}', (doc.inventoryNo || '').replace(/\//g, '-'))
      .replace('{MM}', (month + 1).toString().padStart(2, '0'))
      .replace('{YYYY}', year.toString());
  };

  schema.statics.attach = async function(doc, change, done)
  {
    try
    {
      const data = await doc.toReqTpl();

      const reqTpl = await this.findById(data.reqTplId).lean().exec();

      if (!reqTpl)
      {
        return done();
      }

      const hrtFile = {
        hash: crypto.randomFillSync(Buffer.alloc(16)).toString('hex'),
        type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        size: 0,
        name: this.prepareOutputFileName(reqTpl.outputFileName, doc)
      };

      const outputFile = await this.generate({
        reqTpl,
        data,
        outputFile: path.join(app.fa.config.uploadsDest, `${hrtFile.hash}.xlsx`)
      });

      hrtFile.size = (await fs.stat(outputFile)).size;

      await fs.move(outputFile, outputFile.replace('.xlsx', ''));

      change.data.hrtFile = [doc.hrtFile ? doc.hrtFile.toObject() : null, hrtFile];
      doc.hrtFile = hrtFile;

      done();
    }
    catch (err)
    {
      done(err);
    }
  };

  schema.statics.generate = async function(options)
  {
    let reqTpl = options.reqTpl;

    if (typeof reqTpl === 'string')
    {
      reqTpl = await this.findById(reqTpl).lean().exec();
    }

    if (!reqTpl)
    {
      throw app.createError('Invalid template.', 'INPUT', 400);
    }

    const filesToRemove = [];
    const config = {
      inputFile: path.join(os.tmpdir(), `FA_REQ_TPL_${reqTpl._id}_${Date.now()}_${Math.random()}.xlsx`),
      outputFile: options.outputFile,
      worksheet: reqTpl.worksheet,
      cells: []
    };

    try
    {
      filesToRemove.push(config.inputFile);

      await fs.copy(path.join(app.fa.config.uploadsDest, reqTpl.inputFile.hash), config.inputFile);

      const data = {
        eol: '\r\n',
        ...options.data
      };
      const valueColumns = data.valueColumns || 1;

      reqTpl.cells.forEach(cell =>
      {
        const multi = cell.target.endsWith('+');
        const target = multi ? cell.target.replace(/\+$/, '') : cell.target;

        if (!/\$[a-z]/i.test(cell.value))
        {
          config.cells.push({
            target,
            type: 'string',
            value: multi ? Array(valueColumns).fill(cell.value) : cell.value
          });

          return;
        }

        const value = [];

        for (let i = 0; i < valueColumns; ++i)
        {
          value.push(cell.value.replace(/\$([a-z][a-z0-9]*)/ig, (a0, prop) =>
          {
            prop = data[prop];

            if (prop == null)
            {
              return '';
            }

            if (typeof prop === 'string')
            {
              return prop;
            }

            if (prop.value == null)
            {
              return '';
            }

            const value = Array.isArray(prop.value) ? prop.value[i] : prop.value;

            if (typeof value === 'number')
            {
              return value.toString().replace('.', ',');
            }

            if (typeof value === 'boolean')
            {
              return value ? '1' : '0';
            }

            if (!value)
            {
              return '';
            }

            return String(value);
          }));
        }

        config.cells.push({
          target,
          type: 'string',
          value: multi ? value : value.join(',')
        });
      });

      const configFile = path.join(os.tmpdir(), `FA_REQ_TPL_${reqTpl._id}_${Date.now()}_${Math.random()}.json`);

      filesToRemove.push(configFile);

      await fs.writeFile(configFile, JSON.stringify(config));

      if (process.platform === 'win32')
      {
        await exec(`"${app.fa.config.tplFillerExe}" "${configFile}"`);
      }
      else
      {
        await exec(`dotnet "${app.fa.config.tplFillerExe.replace('.exe', '.dll')}" "${configFile}"`);
      }
    }
    catch (err)
    {
      throw err;
    }
    finally
    {
      filesToRemove.forEach(file => fs.unlink(file, () => {}));
    }

    return options.outputFile;
  };

  return schema;
};
