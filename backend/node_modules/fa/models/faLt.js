// Part of <https://miracle.systems/p/walkner-fa> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const deepEqual = require('deep-equal');
const {transliterate} = require('transliteration');
const lastModifiedPaths = require('h5-mongoose/plugins/lastModifiedPaths');
const userInfoSchema = require('user/models/userInfoSchema');

exports.name = 'FaLt';

exports.setUp = (app, mongoose) =>
{
  const STAGE_PROPS = {
    protocol: [
      'stage',
      'protocolDate',
      'inventoryNo',
      'assetName',
      'costCenter',
      'applicant',
      'cause'
    ],
    verify: [
      'stage',
      'assetName',
      'initialValue',
      'deprecationValue',
      'netValue',
      'economicInitialValue',
      'economicDeprecationValue',
      'economicNetValue',
      'sapNo'
    ],
    acceptOwner: [
      'stage',
      'committee'
    ],
    acceptFinance: [
      'stage'
    ],
    acceptDepartment: [
      'stage'
    ],
    acceptDocument: [
      'stage',
      'documentNo',
      'documentDate',
      'buyerName',
      'buyerAddress',
      'saleValue'
    ],
    record: [
      'stage',
      'accountingNo'
    ],
    finished: [
      'mergeInventoryNo',
      'mergeLineSymbol',
      'mergeType',
      'protocolDate',
      'documentDate',
      'inventoryNo',
      'assetName',
      'costCenter',
      'committee',
      'applicant',
      'cause',
      'initialValue',
      'deprecationValue',
      'netValue',
      'economicInitialValue',
      'economicDeprecationValue',
      'economicNetValue',
      'buyerName',
      'buyerAddress',
      'saleValue',
      'sapNo',
      'accountingNo'
    ],
    cancelled: [
      'stage'
    ]
  };

  const changeSchema = new mongoose.Schema({
    date: {
      type: Date,
      required: true
    },
    user: userInfoSchema,
    data: {},
    comment: {
      type: String,
      trim: true,
      default: ''
    }
  }, {
    _id: false,
    minimize: false
  });

  const ltSchema = new mongoose.Schema({
    createdAt: Date,
    createdBy: userInfoSchema,
    updatedAt: Date,
    updatedBy: userInfoSchema,
    stage: {
      type: String,
      required: true,
      enum: [
        'protocol',
        'verify',
        'acceptOwner',
        'acceptFinance',
        'acceptDepartment',
        'acceptDocument',
        'record',
        'finished',
        'cancelled'
      ]
    },
    stageChangedAt: {
      protocol: Date,
      verify: Date,
      acceptOwner: Date,
      acceptFinance: Date,
      acceptDepartment: Date,
      acceptDocument: Date,
      record: Date
    },
    stageChangedBy: {
      protocol: userInfoSchema,
      verify: userInfoSchema,
      acceptOwner: userInfoSchema,
      acceptFinance: userInfoSchema,
      acceptDepartment: userInfoSchema,
      acceptDocument: userInfoSchema,
      record: userInfoSchema
    },
    kind: {
      type: String,
      required: true,
      enum: ['scrap', 'merge', 'sale', 'other']
    },
    protocolNo: String,
    documentNo: String,
    date: Date,
    protocolDate: Date,
    documentDate: Date,
    inventoryNo: {
      type: String,
      trim: true
    },
    assetName: {
      type: String,
      trim: true
    },
    assetNameSearch: String,
    costCenter: {
      type: String,
      ref: 'FaCostCenter'
    },
    applicant: userInfoSchema,
    committee: [userInfoSchema],
    cause: {
      type: String,
      trim: true
    },
    initialValue: {
      type: Number,
      min: 0
    },
    deprecationValue: {
      type: Number,
      min: 0
    },
    netValue: {
      type: Number
    },
    economicInitialValue: {
      type: Number,
      min: 0
    },
    economicDeprecationValue: {
      type: Number,
      min: 0
    },
    economicNetValue: {
      type: Number
    },
    mergeInventoryNo: {
      type: String,
      trim: true
    },
    mergeLineSymbol: {
      type: String,
      trim: true
    },
    mergeType: {
      type: String,
      enum: [null, 'full', 'partial']
    },
    buyerName: {
      type: String,
      trim: true
    },
    buyerNameSearch: String,
    buyerAddress: {
      type: String,
      trim: true
    },
    saleValue: {
      type: Number,
      min: 0
    },
    sapNo: {
      type: String,
      trim: true
    },
    accountingNo: {
      type: String,
      trim: true
    },
    changes: [changeSchema]
  }, {
    id: false,
    minimize: false
  });

  ltSchema.statics.TOPIC_PREFIX = 'fa.lt';
  ltSchema.statics.BROWSE_LIMIT = 100;
  ltSchema.statics.SEARCH_PROPS = ['assetName', 'buyerName'];

  ltSchema.index({createdAt: -1});
  ltSchema.index({date: -1});
  ltSchema.index({kind: 1});
  ltSchema.index({stage: 1});
  ltSchema.index({protocolNo: 1});
  ltSchema.index({documentNo: 1});
  ltSchema.index({inventoryNo: 1});
  ltSchema.index({sapNo: 1});
  ltSchema.index({accountingNo: 1});
  ltSchema.index({costCenter: 1});
  ltSchema.statics.SEARCH_PROPS.forEach(prop => ltSchema.index({[`${prop}Search`]: 1}));

  ltSchema.pre('save', function(next)
  {
    ltSchema.statics.SEARCH_PROPS.forEach(prop =>
    {
      if (this.isNew || this.isModified(prop))
      {
        this[`${prop}Search`] = this.constructor.prepareSearchText(this[prop]);
      }
    });

    this.date = this.documentDate || this.protocolDate;

    next();
  });

  ltSchema.plugin(lastModifiedPaths);

  ltSchema.statics.prepareSearchText = function(value)
  {
    return transliterate(value, {unknown: ''})
      .replace(/[^A-Za-z0-9]+/g, '')
      .toUpperCase();
  };

  ltSchema.methods.applyChanges = function(input, updatedBy)
  {
    this.updatedAt = new Date();
    this.updatedBy = updatedBy;

    const currentStage = this.stage;
    const comment = input.comment || '';

    input.stage = input.newStage || currentStage;

    if (input.stage !== currentStage)
    {
      const stages = Object.keys(STAGE_PROPS);
      const currentI = stages.indexOf(currentStage);
      const newI = stages.indexOf(input.stage);

      if (currentI + 1 === newI)
      {
        this.stageChangedAt[currentStage] = this.updatedAt;
        this.stageChangedBy[currentStage] = this.updatedBy;
      }
      else if (currentI - 1 === newI)
      {
        this.stageChangedAt[input.stage] = this.updatedAt;
        this.stageChangedBy[input.stage] = this.updatedBy;
      }
      else if (input.newStage !== 'cancelled')
      {
        delete input.stage;
      }
    }

    const changes = this.compareProperties(_.pick(input, STAGE_PROPS[currentStage]));

    if (_.isEmpty(changes) && _.isEmpty(comment))
    {
      return false;
    }

    this.changes.push({
      date: this.updatedAt,
      user: updatedBy,
      data: changes,
      comment
    });

    return true;
  };

  ltSchema.methods.compareProperties = function(input)
  {
    const changes = {};

    _.forEach(input, (value, key) => { this.compareProperty(key, input, changes); });

    return changes;
  };

  ltSchema.methods.compareProperty = function(property, input, changes)
  {
    let oldValue = this[property];
    let newValue = input[property];

    if (_.isObject(oldValue) && _.isFunction(oldValue.toObject))
    {
      oldValue = oldValue.toObject();
    }

    if (_.isObject(newValue) && _.isFunction(newValue.toObject))
    {
      newValue = newValue.toObject();
    }

    if (oldValue instanceof mongoose.Types.ObjectId)
    {
      oldValue = oldValue.toString();
    }

    if (_.isString(newValue))
    {
      newValue = newValue.trim();

      if (/date/i.test(property))
      {
        newValue = new Date(newValue);
      }
    }

    if (deepEqual(newValue, oldValue, {strict: true}))
    {
      return false;
    }

    changes[property] = [oldValue, newValue];
    this[property] = newValue;

    return true;
  };

  mongoose.model(exports.name, ltSchema);
};
