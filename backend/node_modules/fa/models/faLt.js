// Part of <https://miracle.systems/p/walkner-fa> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const deepEqual = require('deep-equal');
const {transliterate} = require('transliteration');
const lastModifiedPaths = require('h5-mongoose/plugins/lastModifiedPaths');
const userInfoSchema = require('user/models/userInfoSchema');
const arrayToObject = require('util/arrayToObject');
const collectUsers = require('./collectUsers');

exports.name = 'FaLt';

exports.setUp = (app, mongoose) =>
{
  const STAGE_PROPS = {
    protocol: [
      'stage',
      'protocolDate',
      'inventoryNo',
      'assetName',
      'costCenter',
      'owner',
      'applicant',
      'cause',
      'committee',
      'committeeAcceptance',
      'attachmentFile'
    ],
    acceptCommittee: [
      'stage',
      'committeeAcceptance',
      'attachmentFile'
    ],
    verify: [
      'stage',
      'assetName',
      'initialValue',
      'deprecationValue',
      'netValue',
      'economicInitialValue',
      'economicDeprecationValue',
      'economicNetValue',
      'sapNo',
      'attachmentFile'
    ],
    acceptOwner: [
      'stage',
      'attachmentFile'
    ],
    acceptFinance: [
      'stage',
      'attachmentFile'
    ],
    acceptDepartment: [
      'stage',
      'attachmentFile'
    ],
    acceptDocument: [
      'stage',
      'documentNo',
      'documentDate',
      'buyerName',
      'buyerAddress',
      'saleValue',
      'attachmentFile'
    ],
    record: [
      'stage',
      'accountingNo',
      'attachmentFile'
    ],
    finished: [
      'mergeInventoryNo',
      'mergeLineSymbol',
      'mergeType',
      'protocolDate',
      'documentDate',
      'inventoryNo',
      'assetName',
      'costCenter',
      'owner',
      'committee',
      'applicant',
      'cause',
      'initialValue',
      'deprecationValue',
      'netValue',
      'economicInitialValue',
      'economicDeprecationValue',
      'economicNetValue',
      'buyerName',
      'buyerAddress',
      'saleValue',
      'sapNo',
      'accountingNo',
      'attachmentFile'
    ],
    cancelled: [
      'stage'
    ]
  };
  const STAGES = Object.keys(STAGE_PROPS);

  const attachmentSchema = new mongoose.Schema({
    hash: String,
    type: String,
    size: Number,
    name: String
  }, {
    _id: false
  });

  const changeSchema = new mongoose.Schema({
    date: {
      type: Date,
      required: true
    },
    user: userInfoSchema,
    data: {},
    comment: {
      trim: true,
      type: String,
      default: ''
    }
  }, {
    _id: false,
    minimize: false
  });

  const schema = new mongoose.Schema({
    createdAt: {
      type: Date,
      required: true
    },
    createdBy: {
      type: userInfoSchema,
      required: true
    },
    updatedAt: {
      type: Date,
      default: null
    },
    updatedBy: {
      type: userInfoSchema,
      default: null
    },
    stage: {
      type: String,
      required: true,
      enum: STAGES
    },
    stageChangedAt: arrayToObject(STAGES, Date),
    stageChangedBy: arrayToObject(STAGES, userInfoSchema),
    kind: {
      type: String,
      required: true,
      enum: ['scrap', 'merge', 'sale', 'other']
    },
    protocolNo: {
      type: String,
      default: ''
    },
    protocolNoInc: {
      type: Number,
      default: 0
    },
    documentNo: {
      type: String,
      default: ''
    },
    documentNoInc: {
      type: Number,
      default: 0
    },
    date: Date,
    protocolDate: {
      type: Date,
      required: true
    },
    documentDate: {
      type: Date,
      default: null
    },
    inventoryNo: {
      type: String,
      trim: true,
      default: ''
    },
    assetName: {
      type: String,
      trim: true,
      default: ''
    },
    assetNameSearch: String,
    costCenter: {
      type: String,
      ref: 'FaCostCenter',
      default: null
    },
    owner: {
      type: userInfoSchema,
      default: null
    },
    applicant: {
      type: userInfoSchema,
      default: null
    },
    committee: [userInfoSchema],
    committeeAcceptance: {},
    cause: {
      type: String,
      trim: true,
      default: ''
    },
    initialValue: {
      type: Number,
      min: 0,
      default: 0
    },
    deprecationValue: {
      type: Number,
      min: 0,
      default: 0
    },
    netValue: {
      type: Number,
      default: 0
    },
    economicInitialValue: {
      type: Number,
      min: 0,
      default: 0
    },
    economicDeprecationValue: {
      type: Number,
      min: 0,
      default: 0
    },
    economicNetValue: {
      type: Number,
      default: 0
    },
    mergeInventoryNo: {
      type: String,
      trim: true,
      default: ''
    },
    mergeLineSymbol: {
      type: String,
      trim: true,
      default: ''
    },
    mergeType: {
      type: String,
      enum: [null, 'full', 'partial'],
      default: null
    },
    buyerName: {
      type: String,
      trim: true,
      default: ''
    },
    buyerNameSearch: String,
    buyerAddress: {
      type: String,
      trim: true,
      default: ''
    },
    saleValue: {
      type: Number,
      min: 0,
      default: 0
    },
    sapNo: {
      type: String,
      trim: true,
      default: ''
    },
    accountingNo: {
      type: String,
      trim: true,
      default: ''
    },
    attachmentFile: {
      type: attachmentSchema,
      default: null
    },
    users: [String],
    changes: [changeSchema]
  }, {
    id: false,
    minimize: false
  });

  schema.statics.TOPIC_PREFIX = 'fa.lt';
  schema.statics.PRIVILEGE_PREFIX = 'FA:LT';
  schema.statics.BROWSE_LIMIT = 100;
  schema.statics.STAGES = STAGES;
  schema.statics.SEARCH_PROPS = ['assetName', 'buyerName'];
  schema.statics.USER_PROPS = ['createdBy', 'owner', 'applicant', 'committee'];

  schema.index({createdAt: -1});
  schema.index({updatedAt: -1});
  schema.index({date: -1});
  schema.index({kind: 1});
  schema.index({stage: 1});
  schema.index({protocolNo: 1});
  schema.index({documentNo: 1});
  schema.index({inventoryNo: 1});
  schema.index({sapNo: 1});
  schema.index({accountingNo: 1});
  schema.index({costCenter: 1});
  schema.statics.SEARCH_PROPS.forEach(prop => schema.index({[`${prop}Search`]: 1}));

  schema.pre('save', function(next)
  {
    this.date = this.documentDate || this.protocolDate;

    schema.statics.SEARCH_PROPS.forEach(prop =>
    {
      if (this.isNew || this.isModified(prop))
      {
        this[`${prop}Search`] = this.constructor.prepareSearchText(this[prop]);
      }
    });

    collectUsers(this, schema.statics.USER_PROPS);

    next();
  });

  schema.plugin(lastModifiedPaths);

  schema.statics.prepareSearchText = function(value)
  {
    return transliterate(value, {unknown: ''})
      .replace(/[^A-Za-z0-9]+/g, '')
      .toUpperCase();
  };

  schema.methods.applyChanges = function(input, updatedBy)
  {
    this.updatedAt = new Date();
    this.updatedBy = updatedBy;

    const currentStage = this.stage;
    const comment = input.comment || '';

    input.stage = input.newStage || currentStage;

    if (input.stage !== currentStage)
    {
      const currentI = STAGES.indexOf(currentStage);
      const newI = STAGES.indexOf(input.stage);

      if (newI < currentI || input.stage === 'cancelled')
      {
        this.stageChangedAt[input.stage] = this.updatedAt;
        this.stageChangedBy[input.stage] = this.updatedBy;
      }
      else if (newI > currentI)
      {
        this.stageChangedAt[currentStage] = this.updatedAt;
        this.stageChangedBy[currentStage] = this.updatedBy;
      }
    }

    const changes = this.compareProperties(_.pick(input, STAGE_PROPS[currentStage]));

    if (_.isEmpty(changes) && _.isEmpty(comment))
    {
      return false;
    }

    this.changes.push({
      date: this.updatedAt,
      user: updatedBy,
      data: changes,
      comment
    });

    return true;
  };

  schema.methods.compareProperties = function(input)
  {
    const changes = {};

    _.forEach(input, (value, key) => { this.compareProperty(key, input, changes); });

    return changes;
  };

  schema.methods.compareProperty = function(property, input, changes)
  {
    let oldValue = this[property];
    let newValue = input[property];

    if (_.isObject(oldValue) && _.isFunction(oldValue.toObject))
    {
      oldValue = oldValue.toObject();
    }

    if (_.isObject(newValue) && _.isFunction(newValue.toObject))
    {
      newValue = newValue.toObject();
    }

    if (oldValue instanceof mongoose.Types.ObjectId)
    {
      oldValue = oldValue.toString();
    }

    if (_.isString(newValue))
    {
      newValue = newValue.trim();

      if (/date/i.test(property))
      {
        newValue = new Date(newValue);
      }
    }

    if (deepEqual(newValue, oldValue, {strict: true}))
    {
      return false;
    }

    changes[property] = [oldValue, newValue];
    this[property] = newValue;

    return true;
  };

  schema.methods.canEdit = function(user)
  {
    const privileges = user.privileges || [];

    if (privileges.includes('SUPER')
      || privileges.includes('FA:MANAGE')
      || privileges.includes('FA:LT:MANAGE'))
    {
      return true;
    }

    switch (this.stage)
    {
      case 'protocol':
        return this.createdBy._id === user._id
          || (!!this.applicant && this.applicant._id === user._id);

      case 'acceptCommittee':
        return !!this.committeeAcceptance && !!this.committeeAcceptance[user._id];

      case 'acceptOwner':
      case 'acceptDocument':
        return !!this.owner && this.owner._id === user._id;

      case 'verify':
      case 'record':
      case 'acceptFinance':
      case 'acceptDepartment':
        return privileges.includes('FA:LT:' + this.stage);

      case 'finished':
        return privileges.includes('SUPER');

      case 'cancelled':
        return user.login === 'root';
    }

    return false;
  };

  return schema;
};
