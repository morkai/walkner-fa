// Part of <https://miracle.systems/p/walkner-fa> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const moment = require('moment');
const step = require('h5.step');
const addRoute = require('./add');
const editRoute = require('./edit');
const findByRidRoute = require('./findByRid');

module.exports = (app, module) =>
{
  const {
    mongoose,
    express,
    user,
    FaOt,
    canAccess
  } = module;

  const canView = user.auth('FA:VIEW', 'FA:OT:VIEW');
  const canAdd = user.auth('FA:MANAGE', 'FA:OT:MANAGE', 'FA:OT:ADD');
  const canEdit = canView;
  const canDelete = user.auth('FA:MANAGE', 'FA:OT:MANAGE');

  express.get('/fa/ot;rid', canView, findByRidRoute.bind(null, app, module));
  express.get(
    '/fa/ot',
    canView,
    limitBrowse,
    prepareSearch,
    express.crud.browseRoute.bind(null, app, FaOt)
  );
  express.post('/fa/ot', canAdd, addRoute.bind(null, app, module));
  express.get('/fa/ot/:id', canView, express.crud.readRoute.bind(null, app, {
    model: FaOt,
    prepareResult: prepareReadResult
  }));
  express.put('/fa/ot/:id', canEdit, editRoute.bind(null, app, module));
  express.delete('/fa/ot/:id', canDelete, express.crud.deleteRoute.bind(null, app, FaOt));

  express.get(
    '/fa/ot;export.:format?',
    canView,
    limitBrowse,
    prepareSearch,
    setUpExport,
    express.crud.exportRoute.bind(null, app, {
      filename: 'FA_OT',
      freezeRows: 1,
      freezeColumns: 2,
      columns: {
        protocolNo: 15,
        documentNo: 15,
        stage: 15,
        protocolNeeded: 'boolean',
        commissioningType: 10,
        usageDestination: 15,
        protocolDate: 'date+utc',
        documentDate: 'date+utc',
        inventoryNo: 15,
        serialNo: 15,
        assetName: 40,
        lineSymbol: 10,
        zplx: 30,
        owner: 20,
        committee: 20,
        supplier: 30,
        costCenter: 10,
        evalGroup1: 20,
        evalGroup5: 20,
        assetClass: 20,
        depRate: 'percent',
        depKey: 10,
        economicMethod: 20,
        fiscalMethod: 20,
        taxMethod: 20,
        economicPeriod: 'integer',
        fiscalPeriod: 'integer',
        taxPeriod: 'integer',
        economicDate: 'date+utc',
        fiscalDate: 'date+utc',
        taxDate: 'date+utc',
        value: {type: 'decimal', decimals: 2},
        transactionType: 30,
        economicValue: 30,
        fiscalValue: 30,
        postingDate: 'date+utc',
        vendorNo: 10,
        vendorName: 30,
        assetNo: 10,
        accountingNo: 10,
        odwNo: 10,
        tplNotes: 100,
        comments: 100
      },
      serializeRow: serializeRow,
      cleanUp: cleanUpExport,
      model: FaOt
    })
  );

  function limitBrowse(req, res, next)
  {
    const sessionUser = req.session.user;
    const privileges = sessionUser.privileges || [];

    if (!privileges.includes('SUPER') && !privileges.includes('FA:VIEW:ALL'))
    {
      const allowedStages = FaOt.STAGES.filter(stage => privileges.includes(`${FaOt.PRIVILEGE_PREFIX}:${stage}`));

      req.rql.selector.args.push({
        name: 'or',
        args: [
          {name: 'eq', args: ['users', sessionUser._id]},
          {name: 'in', args: ['stage', allowedStages]}
        ]
      });
    }

    next();
  }

  function prepareSearch(req, res, next)
  {
    FaOt.SEARCH_PROPS.forEach(prop =>
    {
      const text = req.query[prop];

      if (typeof text !== 'string' || !text.length)
      {
        return;
      }

      const searchText = FaOt.prepareSearchText(text);

      if (!searchText.length)
      {
        return;
      }

      req.rql.selector.args.forEach(term =>
      {
        if (term.name === 'eq' && term.args[0] === prop)
        {
          term.name = 'regex';
          term.args = [`${prop}Search`, _.escapeRegExp(searchText)];
        }
      });
    });

    next();
  }

  function setUpExport(req, res, next)
  {
    req.rql.fields = {};
    req.dictionaries = {};

    step(
      function()
      {
        _.forEach(module.DICTIONARIES, (modelName) =>
        {
          mongoose.model(modelName).find({}, {name: 1}).lean().exec(this.group());
        });
      },
      function(err, dictionaries)
      {
        if (err)
        {
          return next(err);
        }

        Object.keys(module.DICTIONARIES).forEach((dictionaryName, i) =>
        {
          req.dictionaries[dictionaryName] = {};

          dictionaries[i].forEach((dictionaryModel) =>
          {
            req.dictionaries[dictionaryName][dictionaryModel._id] = dictionaryModel;
          });
        });

        setImmediate(next);
      }
    );
  }

  function cleanUpExport(req)
  {
    req.dictionaries = null;
  }

  function serializeRow(doc, req)
  {
    const assetClass = req.dictionaries.assetClasses[doc.assetClass];

    return {
      protocolNo: doc.protocolNo,
      documentNo: doc.documentNo,
      stage: doc.stage,
      protocolNeeded: doc.protocolNeeded,
      commissioningType: doc.commissioningType,
      usageDestination: doc.usageDestination,
      protocolDate: doc.protocolDate,
      documentDate: doc.documentDate,
      inventoryNo: doc.inventoryNo,
      serialNo: doc.serialNo,
      assetName: doc.assetName,
      lineSymbol: doc.lineSymbol,
      zplx: doc.zplx
        .map(zplx =>
        {
          const value = zplx.value.toLocaleString('pl-PL', {
            style: 'currency',
            currency: 'PLN'
          });

          return `ZPLX${zplx.code} (${value})`;
        })
        .join('\r\n'),
      owner: doc.owner ? doc.owner.label : '',
      committee: doc.committee.map(u => u.label).join('\r\n'),
      supplier: doc.supplier,
      costCenter: doc.costCenter,
      evalGroup1: doc.evalGroup1,
      evalGroup5: doc.evalGroup5,
      assetClass: assetClass ? assetClass.name : doc.assetClass,
      depRate: doc.depRate / 100,
      depKey: doc.depKey,
      economicMethod: doc.economicMethod,
      fiscalMethod: doc.fiscalMethod,
      taxMethod: doc.taxMethod,
      economicPeriod: doc.economicPeriod,
      fiscalPeriod: doc.fiscalPeriod,
      taxPeriod: doc.taxPeriod,
      economicDate: doc.economicDate,
      fiscalDate: doc.fiscalDate,
      taxDate: doc.taxDate,
      value: doc.value,
      transactionType: doc.transactions.map(t => t.type).join('; '),
      economicValue: doc.transactions.map(t => t.amount1.toFixed(2).replace('.', ',')).join('; '),
      fiscalValue: doc.transactions.map(t => t.amount2.toFixed(2).replace('.', ',')).join('; '),
      postingDate: doc.postingDate,
      vendorNo: doc.vendorNo,
      vendorName: doc.vendorName,
      assetNo: doc.assetNo,
      accountingNo: doc.accountingNo,
      odwNo: doc.odwNo,
      tplNotes: doc.tplNotes,
      comments: doc.changes
        .filter(c => !!c.comment)
        .map(c => `${c.user.label} @ ${moment(c.date).format('L LT')}: ${c.comment.replace(/\n/g, '\t\n')}`)
        .join('\r\n---\r\n')
    };
  }

  function prepareReadResult(doc, formatResult, req)
  {
    if (!canAccess(FaOt, req.session.user, doc))
    {
      formatResult(app.createError('Not allowed.', 'AUTH', 403));
    }
    else
    {
      formatResult(null, doc);
    }
  }
};
