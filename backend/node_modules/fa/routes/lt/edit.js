// Part of <https://miracle.systems/p/walkner-fa> licensed under <CC BY-NC-SA 4.0>

'use strict';

const step = require('h5.step');

module.exports = (app, module, req, res, next) =>
{
  const {
    user,
    FaLt
  } = module;

  step(
    function()
    {
      FaLt.findById(req.params.id).exec(this.next());
    },
    function(err, doc)
    {
      if (err)
      {
        return this.skip(app.createError(
          `Failed to find a document: ${err.message}`,
          'FIND_FAILURE',
          500,
          {documentId: req.params.id}
        ));
      }

      if (!doc)
      {
        return this.skip(app.createError('Document not found.', 'NOT_FOUND', 404));
      }

      delete req.body.protocolNo;
      delete req.body.documentNo;

      const sessionUser = req.session.user;
      const props = Object.keys(req.body);
      const canEdit = doc.canEdit(sessionUser);
      const canComment = user.isAllowedTo(sessionUser, [['FA:VIEW'], ['FA:LT:VIEW']]);
      const commentOnly = props.includes('comment') && props.length === 1;

      if (!canEdit)
      {
        if (!canComment || !commentOnly)
        {
          return this.skip(app.createError('Not allowed.', 'NO_AUTH', 403));
        }
      }

      props.forEach(prop =>
      {
        if (!prop.endsWith('File'))
        {
          return;
        }

        const attachment = req.body[prop];

        if (!attachment)
        {
          return;
        }

        const tmpAttachment = module.tmpAttachments.get(attachment.hash);

        if (!tmpAttachment)
        {
          return;
        }

        clearTimeout(tmpAttachment.timer);

        module.tmpAttachments.delete(attachment.hash);
      });

      this.doc = doc;

      module.generateNextNo(doc, req.body.newStage, this.next());
    },
    function(err, unlockNoGenerator)
    {
      if (err)
      {
        return this.skip(app.createError(
          `Failed to generate the next document number: ${err.message}`,
          'NO_GENERATION_FAILURE',
          500
        ));
      }

      this.unlockNoGenerator = unlockNoGenerator;

      this.changed = this.doc.applyChanges(req.body, user.createUserInfo(req.session.user, req));

      if (this.changed)
      {
        this.doc.save(this.next());
      }
    },
    function(err)
    {
      if (err)
      {
        return this.skip(app.createError(
          `Failed to save a document: ${err.message}`,
          'SAVE_FAILURE',
          500,
          {documentId: req.params.id}
        ));
      }
    },
    function(err)
    {
      if (this.unlockNoGenerator)
      {
        this.unlockNoGenerator();
      }

      if (err)
      {
        return next(err);
      }

      if (!this.changed)
      {
        res.sendStatus(204);

        return;
      }

      res.json(this.doc);

      app.broker.publish(`${FaLt.TOPIC_PREFIX}.edited`, {
        model: this.doc,
        user: this.doc.updatedBy
      });

      const change = this.doc.changes[this.doc.changes.length - 1].toJSON();
      const omit = ['changes'].concat(Object.keys(change.data));

      app.broker.publish(`${FaLt.TOPIC_PREFIX}.updated.${this.doc._id}`, {
        _id: this.doc._id,
        socketId: req.headers['x-wmes-socket'] || null,
        values: this.doc.lastModifiedValues({omit}),
        change
      });
    }
  );
};
