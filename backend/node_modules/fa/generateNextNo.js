// Part of <https://miracle.systems/p/walkner-fa> licensed under <CC BY-NC-SA 4.0>

'use strict';

const step = require('h5.step');
const moment = require('moment');

const queues = new Map();

module.exports = (app, {FaOt, FaLt}, doc, newStage, done) =>
{
  if (!newStage)
  {
    return done();
  }

  const type = {
    prefix: '',
    property: ''
  };

  switch (doc.constructor)
  {
    case FaOt:
      if (newStage === 'protocol')
      {
        type.prefix = 'POT';
        type.property = 'protocolNo';
      }
      else if (newStage === 'document')
      {
        type.prefix = 'OT';
        type.property = 'documentNo';
      }
      break;

    case FaLt:
      if (newStage === 'protocol')
      {
        type.prefix = 'PZ';
        type.property = 'protocolNo';
      }
      else if (newStage === 'acceptDocument')
      {
        type.prefix = doc.kind === 'sale' ? 'PT' : 'LT';
        type.property = 'documentNo';
      }
      break;
  }

  if (!type.property || !!doc[type.property])
  {
    return done();
  }

  if (queues.has(type.prefix))
  {
    queues.get(type.prefix).push({type, doc, done});

    return;
  }

  queues.set(type.prefix, []);

  generateNext(type, doc, done);
};

function generateNext(type, doc, done)
{
  const now = Date.now();

  step(
    function()
    {
      doc.constructor
        .find({
          createdAt: {
            $gte: moment(now).startOf('year').toDate(),
            $lt: moment(now).startOf('year').add(1, 'years').toDate()
          },
          [type.property]: new RegExp(`^${type.prefix}\\/`)
        })
        .select({[type.property]: 1})
        .sort({[`${type.property}Inc`]: -1})
        .limit(1)
        .lean()
        .exec(this.next());
    },
    function(err, latest)
    {
      if (err)
      {
        done(err);

        unlock(type.prefix);

        return;
      }

      let noInc = 0;
      let no = '';

      if (latest.length)
      {
        const parts = latest[0][type.property].split('/');

        noInc = parseInt(parts[1], 10) + 1;
        parts[1] = noInc.toString();
        no = parts.join('/');
      }
      else
      {
        noInc = 1;
        no = `${type.prefix}/${noInc}/${moment(now).format('YYYY')}`;
      }

      doc[`${type.property}Inc`] = noInc;
      doc[type.property] = no;

      done(null, unlock.bind(null, type.prefix));
    }
  );
}

function unlock(prefix)
{
  const queue = queues.get(prefix);

  if (queue.length)
  {
    const next = queue.shift();

    generateNext(next.type, next.doc, next.done);
  }
  else
  {
    queues.delete(prefix);
  }
}
