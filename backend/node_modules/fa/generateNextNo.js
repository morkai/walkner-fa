// Part of <https://miracle.systems/p/walkner-fa> licensed under <CC BY-NC-SA 4.0>

'use strict';

const step = require('h5.step');
const moment = require('moment');

const queues = new Map();

module.exports = (app, {FaOt, FaLt}, doc, newStage, done) =>
{
  if (!newStage)
  {
    return done();
  }

  const type = {
    prefix: '',
    property: ''
  };

  switch (doc.constructor)
  {
    case FaOt:
      if (newStage === 'protocol')
      {
        type.prefix = 'POT';
        type.property = 'protocolNo';
      }
      else if (newStage === 'document')
      {
        type.prefix = 'OT';
        type.property = 'documentNo';
      }
      break;

    case FaLt:
      if (newStage === 'protocol')
      {
        type.prefix = 'PZ';
        type.property = 'protocolNo';
      }
      else if (newStage === 'acceptDocument')
      {
        type.prefix = doc.kind === 'sale' ? 'PT' : 'LT';
        type.property = 'documentNo';
      }
      break;
  }

  if (!type.property || !!doc[type.property])
  {
    return done();
  }

  if (queues.has(type.prefix))
  {
    queues.get(type.prefix).push({type, doc, done});

    return;
  }

  queues.set(type.prefix, []);

  generateNext(type, doc, done);
};

function generateNext(type, doc, done)
{
  const now = Date.now();

  step(
    function()
    {
      doc.constructor
        .find({
          createdAt: {
            $gte: moment(now).startOf('month').toDate(),
            $lt: moment(now).startOf('month').add(1, 'months').toDate()
          },
          [type.property]: new RegExp(`^${type.prefix}\\/`)
        })
        .select({[type.property]: 1})
        .sort({createdAt: -1})
        .limit(1)
        .lean()
        .exec(this.next());
    },
    function(err, latest)
    {
      if (err)
      {
        done(err);

        unlock(type.prefix);

        return;
      }

      if (latest.length)
      {
        const parts = latest[0][type.property].split('/');

        parts[1] = (parseInt(parts[1], 10) + 1).toString();

        doc[type.property] = parts.join('/');
      }
      else
      {
        doc[type.property] = `${type.prefix}/1/${moment(now).format('M/YYYY')}`;
      }

      done(null, unlock.bind(null, type.prefix));
    }
  );
}

function unlock(prefix)
{
  const queue = queues.get(prefix);

  if (queue.length)
  {
    const next = queue.shift();

    generateNext(next.type, next.doc, next.done);
  }
  else
  {
    queues.delete(prefix);
  }
}
