// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const fs = require('fs');
const step = require('h5.step');
const ejs = require('ejs');
const moment = require('moment');
const {ObjectId} = require('mongoose').Types;

const LANG = require('./lang');
const TEMPLATES = {};

module.exports = (app, module) =>
{
  const {mailSender, User, FaOt, FaLt} = module;
  const logger = module.logger.create({submodule: 'reminder'});

  const PRIVILEGES = [
    'FA:OT:verify',
    'FA:OT:record',
    'FA:LT:verify',
    'FA:LT:acceptFinance',
    'FA:LT:acceptDepartment',
    'FA:LT:record'
  ];

  app.broker.subscribe('app.started', onAppStarted);

  function onAppStarted()
  {
    scheduleNextReminder();
  }

  function scheduleNextReminder()
  {
    const date = moment().startOf('week').add(1, 'week').hours(5).toDate();
    const delay = date.getTime() - Date.now();

    setTimeout(remind, delay);

    logger.info('Scheduled the next reminder.', {date, delay});
  }

  function remind()
  {
    logger.info('Started...');

    step(
      function()
      {
        const conditions = {
          updatedAt: {$lt: Date.now() - 5 * 24 * 3600 * 1000},
          stage: {$nin: ['cancelled', 'finished']}
        };
        const fields = {
          statusesChangedAt: 0,
          users: 0,
          changes: 0
        };

        FaOt
          .find(conditions)
          .select(fields)
          .lean()
          .exec(this.parallel());

        FaLt
          .find(conditions)
          .select(fields)
          .lean()
          .exec(this.parallel());

        User
          .find({
            active: true,
            privileges: {$in: PRIVILEGES}
          })
          .select({
            email: 1,
            privileges: 1
          })
          .lean()
          .exec(this.parallel());
      },
      function(err, ots, lts, users)
      {
        if (err)
        {
          return this.skip(err);
        }

        const privilegeToUsers = {};

        PRIVILEGES.forEach(privilege =>
        {
          privilegeToUsers[privilege] = [];
        });

        users.forEach(user =>
        {
          if (!user.email || !user.email.includes('@'))
          {
            return;
          }

          PRIVILEGES.forEach(privilege =>
          {
            if (user.privileges.includes(privilege))
            {
              privilegeToUsers[privilege].push(user._id.toString());
            }
          });
        });

        const userToDocs = new Map();

        ots.forEach(doc =>
        {
          handleOt(doc).forEach(handleUserInfo.bind(null, doc));
        });

        lts.forEach(doc =>
        {
          handleLt(doc).forEach(handleUserInfo.bind(null, doc));
        });

        setImmediate(this.parallel(), null, userToDocs);

        if (!userToDocs.size)
        {
          setImmediate(this.parallel(), null, []);
        }
        else
        {
          findRecipients(
            {_id: {$in: Array.from(userToDocs.keys()).map(id => new ObjectId(id))}},
            this.parallel()
          );
        }

        function handleUserInfo(doc, userInfo)
        {
          if (privilegeToUsers[userInfo])
          {
            privilegeToUsers[userInfo].forEach(userId =>
            {
              if (!userToDocs.has(userId))
              {
                userToDocs.set(userId, new Set());
              }

              userToDocs.get(userId).add(doc);
            });
          }
          else if (userInfo && userInfo._id)
          {
            if (!userToDocs.has(userInfo._id))
            {
              userToDocs.set(userInfo._id, new Set());
            }

            userToDocs.get(userInfo._id).add(doc);
          }
        }
      },
      function(err, userToDocs, recipients)
      {
        if (err)
        {
          return this.skip(err);
        }

        setImmediate(this.parallel(), null, userToDocs);
        setImmediate(this.parallel(), null, recipients);

        loadTemplates('reminder', recipients, this.parallel());
      },
      function(err, userToDocs, recipients)
      {
        if (err)
        {
          return this.skip(err);
        }

        userToDocs.forEach((docs, userId) =>
        {
          sendEmail(recipients.get(userId), docs, this.group());
        });
      },
      function(err)
      {
        if (err)
        {
          logger.error(err, 'Failed to remind.');
        }
        else
        {
          logger.info('Finished.');
        }

        setTimeout(scheduleNextReminder, 60000);
      }
    );
  }

  function handleOt(doc)
  {
    const users = [];

    switch (doc.stage)
    {
      case 'protocol':
        users.push(
          doc.createdBy,
          doc.stageChangedBy.protocol
        );
        break;

      case 'authorize':
        users.push(
          doc.createdBy,
          doc.stageChangedBy.authorize
        );
        break;

      case 'document':
        users.push(
          doc.createdBy,
          doc.stageChangedBy.document
        );
        break;

      case 'verify':
      {
        if (doc.stageChangedBy.verify)
        {
          users.push(doc.stageChangedBy.verify);
        }
        else
        {
          users.push('FA:OT:verify');
        }

        break;
      }

      case 'accept':
        users.push(doc.owner);
        break;

      case 'record':
        users.push('FA:OT:record');
        break;
    }

    return users;
  }

  function handleLt(doc)
  {
    const users = [];

    switch (doc.stage)
    {
      case 'protocol':
        users.push(
          doc.createdBy,
          doc.stageChangedBy.protocol,
          doc.applicant
        );
        break;

      case 'acceptCommittee':
        doc.committee.forEach(userInfo =>
        {
          if (!doc.committeeAcceptance[userInfo._id]
            || doc.committeeAcceptance[userInfo._id].status === null)
          {
            users.push(userInfo);
          }
        });
        break;

      case 'verify':
      {
        if (doc.stageChangedBy.verify)
        {
          users.push(doc.stageChangedBy.verify);
        }
        else
        {
          users.push('FA:LT:verify');
        }

        break;
      }

      case 'acceptOwner':
        users.push(doc.owner);
        break;

      case 'acceptFinance':
      {
        if (doc.stageChangedBy.acceptFinance)
        {
          users.push(doc.stageChangedBy.acceptFinance);
        }
        else
        {
          users.push('FA:LT:acceptFinance');
        }

        break;
      }

      case 'acceptDepartment':
      {
        if (doc.stageChangedBy.acceptDepartment)
        {
          users.push(doc.stageChangedBy.acceptDepartment);
        }
        else
        {
          users.push('FA:LT:acceptDepartment');
        }

        break;
      }

      case 'acceptDocument':
        users.push(doc.owner);
        break;

      case 'record':
        users.push('FA:LT:record');
        break;
    }

    return users;
  }

  function findRecipients(conditions, done)
  {
    const fields = {
      email: 1,
      'preferences.language': 1
    };

    conditions.active = true;
    conditions['preferences.emails'] = true;

    User.find(conditions).select(fields).lean().exec((err, users) =>
    {
      if (err)
      {
        return done(err);
      }

      const recipients = new Map();

      users.forEach(user =>
      {
        if (user.email && user.email.includes('@'))
        {
          if (!user.preferences)
          {
            user.preferences = {};
          }

          if (!user.preferences.language || !LANG[user.preferences.language])
          {
            user.preferences.language = 'en';
          }

          recipients.set(user._id.toString(), user);
        }
      });

      done(null, recipients);
    });
  }

  function sendEmail(user, docs, done)
  {
    if (!user)
    {
      return done();
    }

    const language = user.preferences.language;
    const lang = LANG[language].reminder;
    const template = TEMPLATES[language].reminder;

    const ots = [];
    const lts = [];

    docs.forEach(doc =>
    {
      if (typeof doc.protocolNeeded === 'boolean')
      {
        ots.push(doc);
      }
      else
      {
        lts.push(doc);
      }
    });

    const email = {
      to: user.email,
      subject: lang(docs),
      html: template({
        urlPrefix: app.options.emailUrlPrefix,
        user,
        ots,
        lts
      })
    };

    mailSender.send(email, (err) =>
    {
      if (err)
      {
        logger.error(err, `Failed to send e-mail.`, {
          email: {
            to: user.email,
            subject: email.subject
          }
        });
      }

      done();
    });
  }

  function loadTemplates(id, recipients, done)
  {
    const uniqLanguages = new Set();

    recipients.forEach(user =>
    {
      uniqLanguages.add(user.preferences.language);
    });

    const languages = Array.from(uniqLanguages);

    step(
      function()
      {
        languages.forEach(lang =>
        {
          if (!TEMPLATES[lang])
          {
            TEMPLATES[lang] = {};
          }

          if (TEMPLATES[lang][id])
          {
            setImmediate(this.group(), null, TEMPLATES[lang][id]);
          }
          else
          {
            fs.readFile(`${__dirname}/../templates/emails/${lang}/${id}.ejs`, 'utf8', this.group());
          }
        });
      },
      function(err, templates)
      {
        if (err)
        {
          return done(err);
        }

        languages.forEach((lang, i) =>
        {
          let template = templates[i];

          if (typeof template === 'string')
          {
            template = ejs.compile(template, {
              cache: true,
              filename: `${__dirname}/../templates/emails/${lang}/${id}.ejs`,
              compileDebug: false,
              rmWhitespace: true
            });
          }

          TEMPLATES[lang][id] = template;
        });

        done();
      }
    );
  }
};
