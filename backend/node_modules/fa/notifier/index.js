// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const fs = require('fs');
const step = require('h5.step');
const ejs = require('ejs');
const {ObjectId} = require('mongoose').Types;

const LANG = require('./lang');
const TEMPLATES = {};

module.exports = (app, module) =>
{
  const {mailSender, User, FaOt} = module;
  const logger = module.logger.create({submodule: 'notifier'});

  app.broker.subscribe('app.started', onAppStarted).setLimit(1);
  app.broker.subscribe('fa.ot.edited', onOtEdited);
  app.broker.subscribe('fa.lt.edited', onLtEdited);

  function onAppStarted()
  {

  }

  function onOtEdited({model})
  {
    const change = model.changes[model.changes.length - 1];

    if (!change)
    {
      return;
    }

    if (!Array.isArray(change.data.stage))
    {
      return;
    }

    const [oldStage, newStage] = change.data.stage;

    switch (newStage)
    {
      case 'document':
      {
        if (oldStage === 'verify')
        {
          return handleOtVerifyRejected(model);
        }

        break;
      }

      case 'verify':
      {
        if (oldStage === 'document')
        {
          return handleOtVerify(model);
        }

        return handleOtAcceptRejected(model);
      }

      case 'accept':
        return handleOtAccept(model);

      case 'record':
        return handleOtRecord(model);

      case 'finished':
        return handleOtFinished(model);
    }
  }

  function onLtEdited({model})
  {
    const change = model.changes[model.changes.length - 1];

    if (!change)
    {
      return;
    }

    if (!Array.isArray(change.data.stage))
    {
      return;
    }

    const [oldStage, newStage] = change.data.stage;

    switch (newStage)
    {
      case 'acceptCommittee':
        return handleLtAcceptCommittee(model);

      case 'verify':
      {
        if (oldStage === 'protocol' || oldStage === 'acceptCommittee')
        {
          return handleLtVerify(model);
        }

        return handleLtAcceptOwnerRejected(model);
      }

      case 'acceptOwner':
      {
        if (oldStage === 'acceptFinance')
        {
          return handleLtAcceptFinanceRejected(model);
        }

        return handleLtAcceptOwner(model);
      }

      case 'acceptFinance':
      {
        if (oldStage === 'acceptDepartment')
        {
          return handleLtAcceptDepartmentRejected(model);
        }

        return handleLtAcceptFinance(model);
      }

      case 'acceptDepartment':
      {
        if (oldStage === 'acceptDocument')
        {
          return handleLtAcceptDocumentRejected(model);
        }

        return handleLtAcceptDepartment(model);
      }

      case 'acceptDocument':
        return handleLtAcceptDocument(model);

      case 'cancelled':
      {
        if (oldStage === 'acceptFinance')
        {
          return handleLtAcceptFinanceCancelled(model);
        }

        if (oldStage === 'acceptDepartment')
        {
          return handleLtAcceptDepartmentCancelled(model);
        }

        break;
      }

      case 'record':
        return handleLtRecord(model);

      case 'finished':
        return handleLtFinished(model);
    }
  }

  function handleOtVerify(doc)
  {
    notifyUsers({privileges: 'FA:OT:verify'}, 'ot.verify', doc);
  }

  function handleOtVerifyRejected(doc)
  {
    const users = multipleUsers([
      doc.stageChangedBy.document
    ]);

    notifyUsers(users, 'ot.verify.rejected', doc);
  }

  function handleOtAccept(doc)
  {
    const users = multipleUsers([
      doc.owner
    ]);

    notifyUsers(users, 'ot.accept', doc);
  }

  function handleOtAcceptRejected(doc)
  {
    const users = multipleUsers([
      doc.stageChangedBy.document,
      doc.stageChangedBy.verify
    ]);

    notifyUsers(users, 'ot.accept.rejected', doc);
  }

  function handleOtRecord(doc)
  {
    notifyUsers({privileges: 'FA:OT:record'}, 'ot.record', doc);
  }

  function handleOtFinished(doc)
  {
    const users = multipleUsers([
      doc.createdBy,
      doc.owner,
      doc.stageChangedBy.document,
      doc.stageChangedBy.accept
    ]);

    notifyUsers(users, 'ot.finished', doc);
  }

  function handleLtAcceptCommittee(doc)
  {
    const users = multipleUsers(doc.committee);

    notifyUsers(users, 'lt.acceptCommittee', doc);
  }

  function handleLtVerify(doc)
  {
    notifyUsers({privileges: 'FA:LT:verify'}, 'lt.verify', doc);
  }

  function handleLtAcceptOwner(doc)
  {
    notifyUsers(singleUser(doc.owner), 'lt.acceptOwner', doc);
  }

  function handleLtAcceptOwnerRejected(doc)
  {
    const users = multipleUsers([
      doc.stageChangedBy.protocol,
      doc.stageChangedBy.verify
    ]);

    notifyUsers(users, 'lt.acceptOwner.rejected', doc);
  }

  function handleLtAcceptFinance(doc)
  {
    notifyUsers({privileges: 'FA:LT:acceptFinance'}, 'lt.acceptFinance', doc);
  }

  function handleLtAcceptFinanceRejected(doc)
  {
    const users = multipleUsers([
      doc.owner,
      doc.stageChangedBy.acceptOwner
    ]);

    notifyUsers(users, 'lt.acceptFinance.rejected', doc);
  }

  function handleLtAcceptFinanceCancelled(doc)
  {
    const users = multipleUsers([
      doc.owner,
      doc.stageChangedBy.acceptOwner
    ]);

    notifyUsers(users, 'lt.acceptFinance.cancelled', doc);
  }

  function handleLtAcceptDepartment(doc)
  {
    notifyUsers({privileges: 'FA:LT:acceptDepartment'}, 'lt.acceptDepartment', doc);
  }

  function handleLtAcceptDepartmentRejected(doc)
  {
    const users = multipleUsers([
      doc.owner,
      doc.stageChangedBy.acceptOwner,
      doc.stageChangedBy.acceptFinance
    ]);

    notifyUsers(users, 'lt.acceptDepartment.rejected', doc);
  }

  function handleLtAcceptDepartmentCancelled(doc)
  {
    const users = multipleUsers([
      doc.owner,
      doc.stageChangedBy.acceptOwner,
      doc.stageChangedBy.acceptFinance
    ]);

    notifyUsers(users, 'lt.acceptDepartment.cancelled', doc);
  }

  function handleLtAcceptDocument(doc)
  {
    const users = multipleUsers([
      doc.owner
    ]);

    notifyUsers(users, 'lt.acceptDocument', doc);
  }

  function handleLtAcceptDocumentRejected(doc)
  {
    const users = multipleUsers([
      doc.stageChangedBy.acceptFinance,
      doc.stageChangedBy.acceptDepartment
    ]);

    notifyUsers(users, 'lt.acceptDocument.rejected', doc);
  }

  function handleLtRecord(doc)
  {
    notifyUsers({privileges: 'FA:LT:record'}, 'lt.record', doc);
  }

  function handleLtFinished(doc)
  {
    const users = multipleUsers([
      doc.createdBy,
      doc.owner,
      doc.stageChangedBy.protocol,
      doc.stageChangedBy.acceptOwner,
      doc.stageChangedBy.acceptDocument
    ]);

    notifyUsers(users, 'lt.finished', doc);
  }

  function multipleUsers(users)
  {
    const userIds = prepareUserIds(users);

    if (userIds.length)
    {
      return {_id: {$in: userIds}};
    }

    return null;
  }

  function singleUser(user)
  {
    const userId = prepareUserIds([user])[0];

    if (userId)
    {
      return {_id: userId};
    }

    return null;
  }

  function prepareUserIds(users)
  {
    return users.filter(u => !!u && !!u._id).map(u => new ObjectId(u._id));
  }

  function updateBySystem(doc)
  {
    doc.constructor.collection.updateOne({_id: doc._id}, {$set: {
      updatedAt: new Date(),
      updatedBy: {
        _id: null,
        label: 'System'
      }
    }}, err =>
    {
      if (err)
      {
        logger.error(err, 'Failed to update by system.', {documentId: doc._id});
      }
    });
  }

  function findRecipients(conditions, doc, done)
  {
    const fields = {
      email: 1,
      'preferences.language': 1
    };

    conditions.active = true;
    conditions['preferences.emails'] = true;

    User.find(conditions).select(fields).lean().exec((err, users) =>
    {
      if (err)
      {
        return done(err);
      }

      const recipients = new Map();

      users.forEach(user =>
      {
        if (user.email && user.email.includes('@'))
        {
          if (!user.preferences)
          {
            user.preferences = {};
          }

          if (!user.preferences.language || !LANG[user.preferences.language])
          {
            user.preferences.language = 'en';
          }

          recipients.set(user._id.toString(), user);
        }
      });

      if (doc)
      {
        ignoreLastChangeUser(doc, recipients);
      }

      done(null, recipients);
    });
  }

  function ignoreLastChangeUser(doc, recipients)
  {
    const change = doc.changes[doc.changes.length - 1];

    recipients.delete(change.user._id.toString());

    return recipients;
  }

  function notifyUsers(userConditions, id, doc)
  {
    if (!userConditions)
    {
      return;
    }

    findRecipients(userConditions, doc, (err, recipients) =>
    {
      if (err)
      {
        logger.error(err, 'Failed to notify users.', {
          documentId: doc._id,
          emailId: id
        });
      }
      else
      {
        sendEmails(id, doc, recipients);
      }
    });
  }

  function sendEmails(id, doc, recipients)
  {
    if (!recipients.size)
    {
      return;
    }

    step(
      function()
      {
        loadTemplates(id, recipients, this.next());
      },
      function(err)
      {
        if (err)
        {
          return this.skip(err);
        }

        recipients.forEach(user =>
        {
          const lang = user.preferences.language;

          sendEmail(user, doc, LANG[lang][id], TEMPLATES[lang][id], this.group());
        });
      },
      function(err)
      {
        if (err)
        {
          return logger.error(err, 'Failed to send e-mails.', {
            documentId: doc._id,
            emailId: id,
            recipients: recipients.map(user => user.email)
          });
        }

        updateBySystem(doc);
      }
    );
  }

  function loadTemplates(id, recipients, done)
  {
    const uniqLanguages = new Set();

    recipients.forEach(user =>
    {
      uniqLanguages.add(user.preferences.language);
    });

    const languages = Array.from(uniqLanguages);

    step(
      function()
      {
        languages.forEach(lang =>
        {
          if (!TEMPLATES[lang])
          {
            TEMPLATES[lang] = {};
          }

          if (TEMPLATES[lang][id])
          {
            setImmediate(this.group(), null, TEMPLATES[lang][id]);
          }
          else
          {
            fs.readFile(`${__dirname}/../templates/emails/${lang}/${id}.ejs`, 'utf8', this.group());
          }
        });
      },
      function(err, templates)
      {
        if (err)
        {
          return done(err);
        }

        languages.forEach((lang, i) =>
        {
          let template = templates[i];

          if (typeof template === 'string')
          {
            template = ejs.compile(template, {
              cache: true,
              filename: `${__dirname}/../templates/emails/${lang}/${id}.ejs`,
              compileDebug: false,
              rmWhitespace: true
            });
          }

          TEMPLATES[lang][id] = template;
        });

        done();
      }
    );
  }

  function sendEmail(user, doc, lang, template, done)
  {
    const email = {
      to: user.email,
      subject: lang.subject(doc),
      html: template({
        urlPrefix: app.options.emailUrlPrefix,
        user,
        doc,
        docType: doc instanceof FaOt ? 'ot' : 'lt'
      })
    };

    mailSender.send(email, (err) =>
    {
      if (err)
      {
        logger.error(err, `Failed to send e-mail.`, {
          documentId: doc._id,
          email: {
            to: user.email,
            subject: email.subject
          }
        });
      }

      done();
    });
  }
};
