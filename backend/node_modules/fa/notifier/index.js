// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const fs = require('fs');
const step = require('h5.step');
const ejs = require('ejs');
const {ObjectId} = require('mongoose').Types;

const LANG = require('./lang');
const TEMPLATES = {};

module.exports = (app, module) =>
{
  const {mailSender, User, FaOt} = module;
  const logger = module.logger.create({submodule: 'notifier'});

  app.broker.subscribe('app.started', onAppStarted).setLimit(1);
  app.broker.subscribe('fa.ot.edited', onOtEdited);
  app.broker.subscribe('fa.lt.edited', onLtEdited);

  function onAppStarted()
  {

  }

  function onOtEdited({model})
  {
    const change = model.changes[model.changes.length - 1];

    if (!change || !Array.isArray(change.data.stage))
    {
      return;
    }

    const [oldStage, newStage] = change.data.stage;
    let users = [];

    switch (newStage)
    {
      case 'protocol':
        users.push(
          model.createdBy,
          model.stageChangedBy.protocol
        );
        break;

      case 'document':
      {
        if (oldStage !== 'authorize')
        {
          users.push(model.stageChangedBy.document);
        }

        break;
      }

      case 'verify':
      {
        if (oldStage === 'document')
        {
          users = {privileges: 'FA:OT:verify'};
        }
        else
        {
          users.push(
            model.stageChangedBy.document,
            model.stageChangedBy.verify
          );
        }

        break;
      }

      case 'accept':
        users.push(model.owner);
        break;

      case 'record':
        users = {privileges: 'FA:OT:record'};
        break;

      case 'finished':
      case 'cancelled':
        users.push(
          model.createdBy,
          model.owner,
          model.stageChangedBy.document,
          model.stageChangedBy.accept
        );
        break;
    }

    if (Array.isArray(users))
    {
      users = multipleUsers(users);
    }

    notifyUsers(users, `ot.${newStage}`, model);
  }

  function onLtEdited({model})
  {
    const change = model.changes[model.changes.length - 1];

    if (!change || !Array.isArray(change.data.stage))
    {
      return;
    }

    const [oldStage, newStage] = change.data.stage;
    let users = [];

    switch (newStage)
    {
      case 'protocol':
        users.push(
          model.createdBy,
          model.stageChangedBy.protocol,
          model.applicant
        );
        break;

      case 'acceptCommittee':
        users = model.committee;
        break;

      case 'verify':
      {
        if (oldStage === 'acceptCommittee')
        {
          users = {privileges: 'FA:LT:verify'};
        }
        else
        {
          users.push(
            model.stageChangedBy.protocol,
            model.stageChangedBy.verify
          );
        }

        break;
      }

      case 'acceptOwner':
      {
        users.push(model.owner);

        if (oldStage !== 'verify')
        {
          users.push(model.stageChangedBy.acceptOwner);
        }

        break;
      }

      case 'acceptFinance':
      {
        if (oldStage === 'acceptOwner')
        {
          users = {privileges: 'FA:LT:acceptFinance'};
        }
        else
        {
          users.push(
            model.owner,
            model.stageChangedBy.acceptOwner,
            model.stageChangedBy.acceptFinance
          );
        }

        break;
      }

      case 'acceptDepartment':
      {
        if (oldStage === 'acceptFinance')
        {
          users = {privileges: 'FA:LT:acceptDepartment'};
        }
        else
        {
          users.push(
            model.owner,
            model.stageChangedBy.acceptOwner,
            model.stageChangedBy.acceptDepartment
          );
        }

        break;
      }

      case 'acceptDocument':
        users.push(model.owner);
        break;

      case 'record':
        users = {privileges: 'FA:LT:record'};
        break;

      case 'finished':
      case 'cancelled':
      {
        users.push(
          model.createdBy,
          model.applicant,
          model.owner,
          model.stageChangedBy.protocol,
          model.stageChangedBy.acceptOwner,
          model.stageChangedBy.acceptDocument
        );

        break;
      }
    }

    if (Array.isArray(users))
    {
      users = multipleUsers(users);
    }

    notifyUsers(users, `lt.${newStage}`, model);
  }

  function multipleUsers(users)
  {
    const userIds = prepareUserIds(users);

    if (userIds.length)
    {
      return {_id: {$in: userIds}};
    }

    return null;
  }

  function prepareUserIds(users)
  {
    return users.filter(u => !!u && !!u._id).map(u => new ObjectId(u._id));
  }

  function updateBySystem(doc)
  {
    doc.constructor.collection.updateOne({_id: doc._id}, {$set: {
      updatedAt: new Date(),
      updatedBy: {
        _id: null,
        label: 'System'
      }
    }}, err =>
    {
      if (err)
      {
        logger.error(err, 'Failed to update by system.', {documentId: doc._id});
      }
    });
  }

  function findRecipients(conditions, doc, done)
  {
    const fields = {
      email: 1,
      'preferences.language': 1
    };

    conditions.active = true;
    conditions['preferences.emails'] = true;

    User.find(conditions).select(fields).lean().exec((err, users) =>
    {
      if (err)
      {
        return done(err);
      }

      const recipients = new Map();

      users.forEach(user =>
      {
        if (user.email && user.email.includes('@'))
        {
          if (!user.preferences)
          {
            user.preferences = {};
          }

          if (!user.preferences.language || !LANG[user.preferences.language])
          {
            user.preferences.language = 'en';
          }

          recipients.set(user._id.toString(), user);
        }
      });

      if (doc)
      {
        ignoreLastChangeUser(doc, recipients);
      }

      done(null, recipients);
    });
  }

  function ignoreLastChangeUser(doc, recipients)
  {
    const change = doc.changes[doc.changes.length - 1];

    recipients.delete(change.user._id.toString());

    return recipients;
  }

  function notifyUsers(userConditions, id, doc)
  {
    if (!userConditions)
    {
      return;
    }

    findRecipients(userConditions, doc, (err, recipients) =>
    {
      if (err)
      {
        logger.error(err, 'Failed to notify users.', {
          documentId: doc._id,
          emailId: id
        });
      }
      else
      {
        sendEmails(id, doc, recipients);
      }
    });
  }

  function sendEmails(id, doc, recipients)
  {
    if (!recipients.size)
    {
      return;
    }

    step(
      function()
      {
        loadTemplates(id, recipients, this.next());
      },
      function(err)
      {
        if (err)
        {
          return this.skip(err);
        }

        recipients.forEach(user =>
        {
          const lang = user.preferences.language;

          sendEmail(user, doc, LANG[lang][id], TEMPLATES[lang][id], this.group());
        });
      },
      function(err)
      {
        if (err)
        {
          return logger.error(err, 'Failed to send e-mails.', {
            documentId: doc._id,
            emailId: id,
            recipients: recipients.map(user => user.email)
          });
        }

        updateBySystem(doc);
      }
    );
  }

  function loadTemplates(id, recipients, done)
  {
    const uniqLanguages = new Set();

    recipients.forEach(user =>
    {
      uniqLanguages.add(user.preferences.language);
    });

    const languages = Array.from(uniqLanguages);

    step(
      function()
      {
        languages.forEach(lang =>
        {
          if (!TEMPLATES[lang])
          {
            TEMPLATES[lang] = {};
          }

          if (TEMPLATES[lang][id])
          {
            setImmediate(this.group(), null, TEMPLATES[lang][id]);
          }
          else
          {
            fs.readFile(`${__dirname}/../templates/emails/${lang}/${id}.ejs`, 'utf8', this.group());
          }
        });
      },
      function(err, templates)
      {
        if (err)
        {
          return done(err);
        }

        languages.forEach((lang, i) =>
        {
          let template = templates[i];

          if (typeof template === 'string')
          {
            template = ejs.compile(template, {
              cache: true,
              filename: `${__dirname}/../templates/emails/${lang}/${id}.ejs`,
              compileDebug: false,
              rmWhitespace: true
            });
          }

          TEMPLATES[lang][id] = template;
        });

        done();
      }
    );
  }

  function sendEmail(user, doc, lang, template, done)
  {
    const email = {
      to: user.email,
      subject: lang(doc),
      html: template({
        urlPrefix: app.options.emailUrlPrefix,
        user,
        doc,
        docType: doc instanceof FaOt ? 'ot' : 'lt'
      })
    };

    mailSender.send(email, (err) =>
    {
      if (err)
      {
        logger.error(err, `Failed to send e-mail.`, {
          documentId: doc._id,
          email: {
            to: user.email,
            subject: email.subject
          }
        });
      }

      done();
    });
  }
};
