// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const os = require('os');
const _ = require('lodash');
const step = require('h5.step');
const resolveIpAddress = require('util/resolveIpAddress');
const userInfoSchema = require('./models/userInfoSchema');

let mongoose = null;
let bcrypt = null;

/* eslint-disable no-empty */

try { mongoose = require('mongoose'); }
catch (err) {}

try { bcrypt = require('bcrypt'); }
catch (err) {}

/* eslint-enable no-empty */

exports.DEFAULT_CONFIG = {
  sioId: 'sio',
  uwsId: 'uws',
  expressId: 'express',
  mongooseId: 'mongoose',
  privileges: [],
  root: {
    password: '$2a$10$qSJWcm1LtN0OzlSHkSRl..ZezbqHAjW2ZuHzBd.F0CTQoWBvf0uQi'
  },
  guest: {},
  localAddresses: null,
  loginFailureDelay: 1000,
  userInfoIdProperty: '_id',
  superPassword: null
};

exports.models = [
  require('./models/user')
];

exports.optionalModules = {
  'express': require('./sockets')
};

exports.onModuleSetUp = (app, {module, setUpAppModule}) =>
{
  (setUpAppModule.userPrivileges || []).forEach(privilege => module.config.privileges.push(privilege));
};

exports.start = (app, module) =>
{
  const localAddresses = module.config.localAddresses || getLocalAddresses();

  module.config.privileges = _.uniq(module.config.privileges);

  module.idProperty = module.config.userInfoIdProperty;

  module.root = Object.assign(module.config.root, {
    loggedIn: true,
    super: true,
    _id: '52a33b8bfb955dac8a92261b',
    login: 'root',
    privileges: ['SUPER']
  });

  module.guest = Object.assign({privileges: []}, module.config.guest, {
    loggedIn: false,
    super: false,
    _id: '52a33b9cfb955dac8a92261c',
    login: 'guest',
    password: undefined
  });

  module.auth = createAuthMiddleware;
  module.authenticate = authenticate;
  module.getRealIp = getRealIp;
  module.isLocalIpAddress = isLocalIpAddress;
  module.isAllowedTo = isAllowedTo;
  module.createUserInfo = createUserInfo;
  module.createGuestData = createGuestData;
  module.preparePrivileges = preparePrivileges;
  module.prepareSessionUser = prepareSessionUser;
  module.getSessionsCollection = getSessionsCollection;
  module.clearSessionCache = clearSessionCache;

  app.broker.subscribe('app.started').setLimit(1).on('message', removeApiSessions);

  app.broker.subscribe('express.beforeRouter').setLimit(1).on('message', (message) =>
  {
    const expressModule = message.module;
    const expressApp = expressModule.app;

    expressApp.use(ensureUserMiddleware);
  });

  app.broker.subscribe('express.fakeSessionCreated', onFakeSessionCreated);

  /**
   * @private
   * @returns {Array.<string>}
   */
  function getLocalAddresses()
  {
    const localAddresses = [];

    _.forEach(os.networkInterfaces(), (addresses) =>
    {
      _.forEach(addresses, (address) =>
      {
        if (address.family === 'IPv4')
        {
          localAddresses.push(address.address.replace(/\.[0-9]+$/, ''));
        }
      });
    });

    return localAddresses;
  }

  /**
   * @param {string} ipAddress
   * @returns {boolean}
   */
  function isLocalIpAddress(ipAddress)
  {
    if (ipAddress === '127.0.0.1' || ipAddress === '::1')
    {
      return true;
    }

    for (let i = 0, l = localAddresses.length; i < l; ++i)
    {
      const pattern = localAddresses[i];

      if (typeof pattern === 'string')
      {
        if (ipAddress.indexOf(pattern) === 0)
        {
          return true;
        }
      }
      else if (pattern.test(ipAddress))
      {
        return true;
      }
    }

    return false;
  }

  function isEmbeddedClient(req)
  {
    return (!!req.headers && !!req.headers['user-agent'] && req.headers['user-agent'].includes('X11; Linux'))
      || (app.options.env === 'development' && req.query && req.query._embedded === '1');
  }

  /**
   * @private
   * @param {Object} addressData
   * @returns {Object}
   */
  function createGuestData(addressData)
  {
    return prepareSessionUser(_.cloneDeep(module.guest), false, addressData);
  }

  /**
   * @param {Object} user
   * @param {boolean} loggedIn
   * @param {Object} addressData
   * @returns {Object}
   */
  function prepareSessionUser(user, loggedIn, addressData)
  {
    delete user.password;
    delete user.apiKey;

    user._id = user._id.toString();
    user.loggedIn = loggedIn;
    user.ipAddress = getRealIp({}, addressData);
    user.local = isLocalIpAddress(user.ipAddress);
    user.embedded = user.local && isEmbeddedClient(addressData);
    user.super = _.includes(user.privileges, 'SUPER');
    user.app = !!addressData.headers && addressData.headers['x-wmes-app'] || null;

    return user;
  }

  function isAllowedTo(user, anyPrivileges)
  {
    if (!user || !Array.isArray(user.privileges))
    {
      return false;
    }

    if (typeof anyPrivileges === 'string')
    {
      anyPrivileges = [[anyPrivileges]];
    }

    if (!Array.isArray(anyPrivileges))
    {
      throw new Error(`[anyPrivileges] must be a string or an array.`);
    }

    if (user.privileges.includes('SUPER'))
    {
      return true;
    }

    if (!anyPrivileges.length)
    {
      return true;
    }

    for (let i = 0, l = anyPrivileges.length; i < l; ++i)
    {
      const allPrivileges = anyPrivileges[i];
      let matches = 0;

      for (let ii = 0; ii < allPrivileges.length; ++ii)
      {
        const privilege = allPrivileges[ii];

        if (typeof privilege === 'function')
        {
          matches += privilege(user);
        }
        else if (privilege === 'USER')
        {
          matches += user.loggedIn ? 1 : 0;
        }
        else if (privilege === 'LOCAL')
        {
          matches += user.local ? 1 : 0;
        }
        else if (privilege === 'LOCALHOST')
        {
          matches += user.ipAddress === '127.0.0.1' ? 1 : 0;
        }
        else if (privilege === 'EMBEDDED')
        {
          matches += user.embedded ? 1 : 0;
        }
        else if (/^FN:/.test(privilege))
        {
          const requiredFn = privilege.substring(3);

          if (requiredFn.includes('*'))
          {
            const requiredFnRe = new RegExp(`^${requiredFn.replace(/\*/g, '.*?')}$`);

            matches += requiredFnRe.test(user.prodFunction) ? 1 : 0;
          }
          else
          {
            matches += user.prodFunction === requiredFn ? 1 : 0;
          }
        }
        else if (/^APP:/.test(privilege))
        {
          const requiredApp = privilege.substring(4) + '|';

          matches += requiredApp.includes(user.app + '|');
        }
        else
        {
          matches += hasPrivilege(user, allPrivileges[ii]) ? 1 : 0;
        }
      }

      if (matches === allPrivileges.length)
      {
        return true;
      }
    }

    return false;
  }

  function preparePrivileges(user)
  {
    if (!Array.isArray(user.privileges))
    {
      user.privileges = [];
    }

    user.privilegesString = '|' + user.privileges.join('|');
    user.privilegesMap = {};

    user.privileges.forEach(privilege =>
    {
      user.privilegesMap[privilege] = true;
    });

    user.super = user.privilegesMap.SUPER === true;

    return user;
  }

  function hasPrivilege(user, privilege)
  {
    if (_.isEmpty(user.privilegesString))
    {
      preparePrivileges(user);
    }

    if (privilege.endsWith('*'))
    {
      return user.privilegesString.includes('|' + privilege.substr(0, privilege.length - 1));
    }

    return user.privilegesMap[privilege] === true;
  }

  function ensureUserMiddleware(req, res, next)
  {
    if (!req.session)
    {
      return next();
    }

    const user = req.session.user;

    if (!user)
    {
      req.session.user = createGuestData(req);
    }

    return next();
  }

  /**
   * @returns {function(object, object, function)}
   */
  function createAuthMiddleware(...args)
  {
    const anyPrivileges = [];

    for (let i = 0, l = args.length; i < l; ++i)
    {
      let allPrivileges = args[i];

      if (!Array.isArray(allPrivileges))
      {
        allPrivileges = [allPrivileges];
      }

      anyPrivileges.push(allPrivileges);
    }

    return function authMiddleware(req, res, next)
    {
      if (!res && !next)
      {
        return isAllowedTo(req, anyPrivileges);
      }

      step(
        function()
        {
          let sessionUser = req.session && req.session.user;

          if (!sessionUser)
          {
            sessionUser = createGuestData(req);
          }

          const apiKey = req.query.apiKey
            || req.body?.apiKey
            || req.headers['x-api-key']
            || null;

          if (sessionUser._id === module.guest._id && typeof apiKey === 'string' && apiKey.length)
          {
            resolveApiUser(sessionUser, apiKey, req, this.next());
          }
          else
          {
            setImmediate(this.next(), null, sessionUser);
          }
        },
        function(err, sessionUser)
        {
          if (err)
          {
            return this.skip(err);
          }

          if (req.session)
          {
            req.session.user = sessionUser;
          }

          if (sessionUser.apiUser)
          {
            req.sessionID = null;
          }

          if (!isAllowedTo(sessionUser, anyPrivileges))
          {
console.log('403', {
  anyPrivileges,
  sessionId: req.sessionID,
  sessionUser
});
            return this.skip(app.createError('Not allowed.', 'AUTH', 403, {
              method: req.method,
              url: req.url,
              privileges: anyPrivileges,
              user: _.pick(sessionUser, ['_id', 'login', 'ipAddress', 'app', 'prodFunction', 'privileges'])
            }));
          }
        },
        next
      );
    };
  }

  function resolveApiUser(sessionUser, apiKey, req, done)
  {
    const {User} = module;
    const apiUserId = req.headers['x-api-user'];

    step(
      function()
      {
        User.findOne({apiKey, active: true}).exec(this.parallel());

        if (apiUserId && apiUserId !== module.guest._id)
        {
          User.findById(apiUserId).exec(this.parallel());
        }
      },
      function(err, apiUser, loggedUser)
      {
        if (err)
        {
          return done(err);
        }

        if (!apiUser)
        {
          return done(app.createError('Unknown user API key.', 'INPUT', 401));
        }

        if (apiUserId && apiUserId !== module.guest._id && !loggedUser)
        {
          return done(app.createError('Unknown API user.', 'INPUT', 400));
        }

        const user = loggedUser || apiUser;

        Object.assign(sessionUser, user.toObject());
        prepareSessionUser(sessionUser, true, req);

        sessionUser.apiUser = true;

        delete sessionUser.privilegesString;
        delete sessionUser.privilegesMap;

        done(null, sessionUser);
      }
    );
  }

  function authenticate(credentials, done)
  {
    const apiKey = typeof credentials.apiKey === 'string' && credentials.apiKey.length >= 32
      ? credentials.apiKey
      : null;

    step(
      function()
      {
        if (apiKey)
        {
          return;
        }

        if (!_.isString(credentials.login)
          || _.isEmpty(credentials.login)
          || !_.isString(credentials.password)
          || _.isEmpty(credentials.password))
        {
          return this.skip(app.createError(`Invalid credentials.`, 'INPUT', 400));
        }
      },
      function findUserDataStep()
      {
        const next = this.next();

        if (!apiKey && credentials.login.toLowerCase() === module.root.login.toLowerCase())
        {
          next(null, [{...module.root}]);

          return;
        }

        const User = app[module.config.mongooseId].model('User');
        const conditions = {};
        let property;
        let value;

        if (apiKey)
        {
          property = 'apiKey';
          value = apiKey;
        }
        else
        {
          property = /^.*?@.*?\.[a-zA-Z]+$/.test(credentials.login) ? 'email' : 'login';
          value = new RegExp(`^${_.escapeRegExp(credentials.login)}$`, 'i');
        }

        conditions[property] = value;

        if (User.schema.path('active'))
        {
          conditions.active = true;
        }

        User.find(conditions).exec(next);
      },
      function checkUserDataStep(err, users)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (users.length === 0)
        {
          return this.skip(app.createError(`Invalid credentials.`, 'INPUT', 401));
        }

        if (users.length > 1)
        {
          return this.skip(app.createError(`Many matching users found.`, 'MANY_MATCHES', 400));
        }

        const userData = _.isFunction(users[0].toObject)
          ? users[0].toObject()
          : users[0];

        const hasAnyPrivileges = !_.isEmpty(userData.privileges);
        const hasProdFunction = !_.isEmpty(userData.prodFunction);
        const hasUnsafePassword = !apiKey && (userData.login === credentials.password
          || userData.personnelId === credentials.password);
        const hasEmailAddress = _.isString(userData.email) && userData.email.includes('@');

        if (hasUnsafePassword && (hasAnyPrivileges || hasProdFunction) && hasEmailAddress)
        {
          return this.skip(app.createError(`Unsafe password: reset required.`, 'UNSAFE_PASSWORD', 400));
        }

        this.userData = userData;
        this.password = users[0].password;
      },
      function comparePasswordStep()
      {
        if (apiKey || (module.config.superPassword && credentials.password === module.config.superPassword))
        {
          setImmediate(this.next(), null, true);
        }
        else if (bcrypt)
        {
          bcrypt.compare(credentials.password, this.password, this.next());
        }
        else
        {
          setImmediate(this.next(), null, credentials.password === this.password);
        }
      },
      function handleComparePasswordResultStep(err, result)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!result)
        {
          return this.skip(app.createError(`Invalid credentials.`, 'INPUT', 401));
        }
      },
      function(err)
      {
        if (err)
        {
          delayAuthFailure(err, done);
        }
        else
        {
          done(null, this.userData);
        }
      }
    );
  }

  function delayAuthFailure(err, done)
  {
    setTimeout(done, module.config.loginFailureDelay, err);
  }

  function createUserInfo(userData, addressData)
  {
    if (!userData)
    {
      userData = {};
    }

    if (!addressData)
    {
      addressData = {};
    }

    const userInfo = {
      [module.config.userInfoIdProperty]: module.guest._id.toString(),
      label: module.guest.login
    };

    try
    {
      const userId = String(userData._id || userData.id);

      userInfo[module.config.userInfoIdProperty] = mongoose
        ? mongoose.Types.ObjectId.createFromHexString(userId).toHexString()
        : userId;
    }
    catch (err) {} // eslint-disable-line no-empty

    if (typeof userData.label === 'string')
    {
      userInfo.label = userData.label;
    }
    else if (userData.lastName)
    {
      userInfo.label = (userData.lastName + ' ' + userData.firstName).trim();
    }
    else if (userData.login)
    {
      userInfo.label = String(userData.login);
    }

    const ip = getRealIp(userData, addressData);

    if (ip !== '0.0.0.0')
    {
      userInfo.ip = ip;
    }

    userInfoSchema.statics.decorators.forEach(decorate => decorate(userInfo, userData, addressData));

    return userInfo;
  }

  function getRealIp(userData, addressData)
  {
    let ip = '';

    if (addressData)
    {
      ip = resolveIpAddress(addressData);
    }

    if (ip === '')
    {
      ip = userData.ip || userData.ipAddress || '0.0.0.0';
    }

    return ip;
  }

  function getSessionsCollection()
  {
    const express = app[module.config.expressId];

    if (!express)
    {
      return null;
    }

    const sessionStore = express.sessionStore;

    if (sessionStore && typeof sessionStore.collection === 'function')
    {
      return sessionStore.collection();
    }

    return null;
  }

  function removeApiSessions()
  {
    const sessionsCollection = getSessionsCollection();

    if (!sessionsCollection)
    {
      return;
    }

    const User = app[module.config.mongooseId].model('User');

    if (!User.schema.path('apiKey'))
    {
      return;
    }

    step(
      function()
      {
        User
          .find({apiKey: {$ne: ''}})
          .select({_id: 1})
          .lean()
          .exec(this.next());
      },
      function(err, apiUsers)
      {
        if (err)
        {
          return this.skip(err);
        }

        const ids = apiUsers.map(u => u._id.toString());

        if (!ids.length)
        {
          return this.skip();
        }

        sessionsCollection.deleteMany({'data.user._id': {$in: ids}}, this.next());
      },
      function(err)
      {
        if (err)
        {
          module.error(err, 'Failed to remove API user sessions.');
        }

        clearSessionCache();

        setTimeout(removeApiSessions, 3600_000);
      }
    );
  }

  function clearSessionCache()
  {
    const {sessionStore} = app[module.config.expressId];

    if (sessionStore && sessionStore.cache && sessionStore.cache.clear)
    {
      sessionStore.cache.clear();
    }
  }

  function onFakeSessionCreated({req})
  {
    req.session.user = createGuestData(req);
  }
};
