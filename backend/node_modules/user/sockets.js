// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

let cookie = null;
let cookieParser = null;

/* eslint-disable no-empty */

try { cookie = require('cookie'); }
catch (err) {}

try { cookieParser = require('cookie-parser'); }
catch (err) {}

/* eslint-enable no-empty */

module.exports = (app, module) =>
{
  const {express} = module;

  const sosMap = {};
  const usersToSocketsMap = {};

  app.onModuleReady(module.config.sioId, setUpSio);
  app.onModuleReady(module.config.uwsId, setUpUws);

  app.broker.subscribe('sockets.connected', ({socket}) =>
  {
    handleConnection(socket);
  });

  app.broker.subscribe('sockets.disconnected.*', ({socket}) =>
  {
    handleDisconnection(socket);
  });

  app.broker.subscribe('users.login', ({user, oldSessionId, newSessionId}) =>
  {
    handleUserLogin(user, oldSessionId, newSessionId);
  });

  app.broker.subscribe('users.logout', ({user, oldSessionId, newSessionId}) =>
  {
    handleUserLogout(user, oldSessionId, newSessionId);
  });

  app.broker.subscribe('users.edited', ({model}) =>
  {
    handleUserEdit(usersToSocketsMap[model._id], model.toJSON());
  });

  app.broker.subscribe('users.updated.*', (updatedUser) =>
  {
    handleUserUpdate(usersToSocketsMap[updatedUser._id], {...updatedUser});
  });

  app.broker.subscribe('users.deleted', ({model}) =>
  {
    handleUserDelete(usersToSocketsMap[model._id], model._id);
  });

  function id2socket(socketId)
  {
    return module.uws?.sockets.get(socketId) ?? module.sio?.sockets.connected[socketId];
  }

  function setUpSio()
  {
    module.sio.use(handleUpgrade);
  }

  function setUpUws()
  {
    module.uws.on('upgrade', handleUpgrade);
  }

  function handleUpgrade(socket, done)
  {
    if (!cookie || !cookieParser)
    {
      return done(app.createError('No cookie or cookie-parser module.', 'DEPENDENCIES', 500));
    }

    const handshakeData = socket.handshake;
    const cookies = cookie.parse(String(handshakeData.headers.cookie));
    const sessionCookie = cookies[express.config.sessionCookieKey];

    if (typeof sessionCookie !== 'string')
    {
      handshakeData.sessionId = Date.now() + '' + Math.random();
      handshakeData.user = module.createGuestData(handshakeData);

      return done();
    }

    const sessionId = cookieParser.signedCookie(sessionCookie, express.config.cookieSecret);

    express.sessionStore.get(sessionId, (err, session) =>
    {
      if (err)
      {
        return done(err);
      }

      handshakeData.sessionId = sessionId;
      handshakeData.user = session && session.user
        ? session.user
        : module.createGuestData(handshakeData);

      return done();
    });
  }

  function handleConnection(socket)
  {
    if (!socket)
    {
      return;
    }

    if (socket.handshake.sessionId)
    {
      if (!sosMap[socket.handshake.sessionId])
      {
        sosMap[socket.handshake.sessionId] = {};
      }

      sosMap[socket.handshake.sessionId][socket.id] = true;
    }

    if (socket.handshake.user)
    {
      socket.emit('user.reload', socket.handshake.user);
    }

    mapUserToSocket(socket);
  }

  function mapUserToSocket(socket)
  {
    if (!socket.handshake.user || !socket.handshake.user.loggedIn)
    {
      return;
    }

    const userId = socket.handshake.user._id;

    if (!usersToSocketsMap[userId])
    {
      usersToSocketsMap[userId] = {};
    }

    usersToSocketsMap[userId][socket.id] = true;
  }

  function handleDisconnection(socket)
  {
    const userSockets = socket.handshake.user ? usersToSocketsMap[socket.handshake.user._id] : null;

    if (userSockets)
    {
      delete userSockets[socket.id];

      if (Object.keys(userSockets).length === 0)
      {
        delete userSockets[socket.handshake.user._id];
      }
    }

    const sessionSockets = sosMap[socket.handshake.sessionId];

    if (sessionSockets)
    {
      delete sessionSockets[socket.id];

      if (Object.keys(sessionSockets).length === 0)
      {
        delete sessionSockets[socket.handshake.sessionId];
      }
    }
  }

  function moveSos(oldSessionId, newSessionId)
  {
    const sockets = [];

    if (!sosMap[oldSessionId])
    {
      return sockets;
    }

    for (const socketId of Object.keys(sosMap[oldSessionId]))
    {
      const socket = id2socket(socketId);

      if (typeof socket === 'undefined')
      {
        delete sosMap[oldSessionId][socketId];
      }
      else
      {
        socket.handshake.sessionId = newSessionId;

        sockets.push(socket);
      }
    }

    if (newSessionId !== oldSessionId)
    {
      sosMap[newSessionId] = sosMap[oldSessionId];

      delete sosMap[oldSessionId];
    }

    return sockets;
  }

  function handleUserLogin(userData, oldSessionId, newSessionId)
  {
    moveSos(oldSessionId, newSessionId).forEach(socket =>
    {
      socket.handshake.sessionId = newSessionId;
      socket.handshake.user = userData;

      mapUserToSocket(socket);

      socket.emit('user.reload', userData);
    });
  }

  function handleUserLogout(userData, oldSessionId, newSessionId)
  {
    const userSocketsMap = usersToSocketsMap[userData._id];

    moveSos(oldSessionId, newSessionId).forEach(socket =>
    {
      socket.handshake.sessionId = newSessionId;
      socket.handshake.user = module.createGuestData(socket.handshake);

      if (userSocketsMap && userSocketsMap[socket.id])
      {
        delete userSocketsMap[socket.id];

        if (Object.keys(userSocketsMap).length === 0)
        {
          delete usersToSocketsMap[userData._id];
        }
      }

      socket.emit('user.reload', socket.handshake.user);
    });
  }

  function handleUserEdit(userToSocketsMap, userData)
  {
    const userId = userData._id.toString();

    delete userData._id;

    module.preparePrivileges(userData);
    updateUserSessions(userId, userData);
    updateUserSockets(userToSocketsMap, userData);
  }

  function handleUserUpdate(userToSocketsMap, userData)
  {
    const userId = userData._id.toString();

    delete userData._id;

    if (userData.privileges)
    {
      module.preparePrivileges(userData);
    }

    updateUserSessions(userId, userData);
    updateUserSockets(userToSocketsMap, userData);
  }

  function handleUserDelete(userToSocketsMap, userId)
  {
    removeUserSessions(userId);

    if (!userToSocketsMap)
    {
      return;
    }

    Object.values(userToSocketsMap).forEach(socketId =>
    {
      const socket = id2socket(socketId);

      if (socket)
      {
        socket.emit('user.deleted');
      }
    });
  }

  function updateUserSockets(userToSocketsMap, userData)
  {
    if (!userToSocketsMap)
    {
      return;
    }

    Object.values(userToSocketsMap).forEach(socketId =>
    {
      const socket = id2socket(socketId);

      if (socket)
      {
        Object.assign(socket.handshake.user, userData);

        socket.emit('user.reload', socket.handshake.user);
      }
    });
  }

  function updateUserSessions(userId, userData)
  {
    const collection = module.getSessionsCollection();

    if (!collection)
    {
      return;
    }

    const conditions = {
      'data.user._id': userId
    };

    if (userData.active === false)
    {
      return collection.deleteMany(conditions, err =>
      {
        if (err)
        {
          module.error(err, `Failed to remove sessions for deactivated user.`, {userId});
        }
        else
        {
          module.clearSessionCache();
        }
      });
    }

    const update = {
      $set: {}
    };

    Object.keys(userData).forEach(k =>
    {
      update.$set[`data.user.${k}`] = userData[k];
    });

    collection.updateMany(conditions, update, err =>
    {
      if (err)
      {
        module.error(err, `Failed to update user sessions.`, {userId});
      }
      else
      {
        module.clearSessionCache();
      }
    });
  }

  function removeUserSessions(userId)
  {
    const collection = module.getSessionsCollection();

    if (!collection)
    {
      return;
    }

    collection.deleteMany({'data.user._id': userId.toString()}, (err) =>
    {
      if (err)
      {
        module.error(err, `Failed to remove user sessions.`);
      }

      module.clearSessionCache();
    });
  }
};
