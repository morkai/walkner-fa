// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const path = require('path');
const fs = require('fs');
const _ = require('lodash');
const step = require('h5.step');
const request = require('request');
const {transliterate} = require('transliteration');

exports.DEFAULT_CONFIG = {
  expressId: 'express',
  twilioId: 'twilio',
  secretKey: null,
  remoteCallerUrl: null,
  callPath: null,
  transliterate: false,
  serwersms: null
};

exports.onModuleSetUp = (app, {module, setUpModule}) =>
{
  if (setUpModule.name === module.config.expressId)
  {
    setUpModule.config.noSessionPatterns.push(req => req.url === '/caller;call');
  }
};

exports.start = (app, module) =>
{
  app.onModuleReady(module.config.expressId, setUpRoutes);

  /**
   * @param {(string|Array.<string>)} to
   * @param {string} text
   * @param {function((Error|null), Object)} done
   * @returns {undefined}
   */
  module.call = function(to, text, done)
  {
    let callOptions;

    if (arguments.length > 2)
    {
      callOptions = {to, text};
    }
    else
    {
      callOptions = to;
      done = text;
    }

    if (typeof callOptions.to === 'string')
    {
      callOptions.to = [callOptions.to];
    }

    if (!Array.isArray(callOptions.to) || !callOptions.to.length)
    {
      return setImmediate(done, new Error('No recipients.'));
    }

    if (module.config.transliterate && !_.isEmpty(callOptions.text))
    {
      callOptions.text = transliterate(callOptions.text, {unknown: '?'});
    }

    if (app[module.config.twilioId])
    {
      callThroughTwilio(callOptions, done);
    }
    else if (module.config.serwersms)
    {
      callThroughSerwersms(callOptions, done);
    }
    else if (module.config.remoteCallerUrl)
    {
      callThroughRemote(callOptions, done);
    }
    else if (!_.isEmpty(module.config.callPath))
    {
      callThroughFile(callOptions, done);
    }
    else
    {
      module.info('Not calling.', {callOptions});

      setImmediate(done);
    }
  };

  function callThroughRemote(callOptions, done)
  {
    const options = {
      url: module.config.remoteCallerUrl,
      method: 'POST',
      json: true,
      body: {...callOptions, secretKey: module.config.secretKey}
    };

    request(options, (err, res) =>
    {
      if (!err && res && res.statusCode !== 204)
      {
        err = new Error(`Invalid response status. Expected 204, got: ${res.statusCode}.`);
      }

      if (err)
      {
        module.error(err, `Failed to call.`, {
          mode: 'remote',
          callOptions: _.omit(options.body, ['secretKey'])
        });

        return done(err);
      }

      module.debug(`Called.`, {
        mode: 'remote',
        callOptions: _.omit(options.body, ['secretKey'])
      });

      return done();
    });
  }

  function callThroughFile(callOptions, done)
  {
    step(
      function openFileStep()
      {
        const smsFileName = 'WMES_'
          + Math.round(Date.now() + Math.random() * 99999999).toString(36).toUpperCase()
          + '.call';

        fs.open(path.join(module.config.callPath, smsFileName), 'wx+', this.next());
      },
      function writeFileStep(err, fd)
      {
        if (err)
        {
          return this.done(done, err);
        }

        this.fd = fd;

        const contents = callOptions.to.join('') + ',' + callOptions.text;

        fs.write(fd, contents, 0, 'utf8', this.next());
      },
      function closeFileStep(err)
      {
        const fd = this.fd;
        this.fd = null;

        if (err)
        {
          fs.close(fd, () => {});

          module.error(err, `Failed to call.`, {
            mode: 'file',
            callOptions: _.omit(callOptions, ['secretKey'])
          });

          return done(err);
        }

        module.debug(`Called.`, {
          mode: 'file',
          callOptions: _.omit(callOptions, ['secretKey'])
        });

        fs.close(fd, done);
      }
    );
  }

  function callThroughTwilio(callOptions, done)
  {
    const twilio = app[module.config.twilioId];

    step(
      function()
      {
        callOptions.to.forEach(to =>
        {
          twilio.say({...callOptions, to, message: callOptions.text}, this.group());
        });
      },
      function(err)
      {
        if (err)
        {
          module.error(err, `Failed to call.`, {
            mode: 'twilio',
            callOptions: _.omit(callOptions, ['secretKey'])
          });

          return done(err);
        }

        module.debug(`Called.`, {
          mode: 'twilio',
          callOptions: _.omit(callOptions, ['secretKey'])
        });

        done();
      }
    );
  }

  function callThroughSerwersms(smsOptions, done)
  {
    const config = module.config.serwersms;
    const options = {
      url: 'https://api2.serwersms.pl/messages/send_voice.json',
      method: 'POST',
      json: true,
      body: {
        username: config.username,
        password: config.password,
        sender_number: config.sender, // eslint-disable-line camelcase
        phone: smsOptions.to,
        text: smsOptions.text
      }
    };

    request(options, (err, res) =>
    {
      if (!err && res && res.body && res.body.error)
      {
        err = new Error(`SerwerSMS error (${res.body.error.type}): ${res.body.error.message}`);
      }
      else if (!err && (!res || !res.body || res.body.success !== true))
      {
        err = new Error('Invalid SerwerSMS response.');
      }

      if (err)
      {
        module.error(err, `Failed to call.`, {
          mode: 'serwersms',
          callOptions: _.omit(options.body, ['password'])
        });

        return done(err);
      }

      module.debug(`Sent SMS.`, {
        mode: 'serwersms',
        callOptions: _.omit(options.body, ['password'])
      });

      return done();
    });
  }

  function setUpRoutes()
  {
    const express = app[module.config.expressId];

    express.options('/caller;call', (req, res) =>
    {
      res.set('Access-Control-Allow-Origin', '*');
      res.set('Access-Control-Allow-Headers', req.headers['access-control-request-headers'] || '');
      res.end();
    });

    express.post('/caller;call', (req, res, next) =>
    {
      res.set('Access-Control-Allow-Origin', '*');
      res.set('Access-Control-Allow-Headers', req.headers['access-control-request-headers'] || '');

      if (module.config.secretKey !== null && req.body.secretKey !== module.config.secretKey)
      {
        return next(app.createError('INVALID_SECRET_KEY', 401));
      }

      module.call(req.body, (err) =>
      {
        if (err)
        {
          return next(err);
        }

        res.sendStatus(204);
      });
    });
  }
};
